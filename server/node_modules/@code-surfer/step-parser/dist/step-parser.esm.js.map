{"version":3,"file":"step-parser.esm.js","sources":["../src/differ.ts","../src/tokenizer.ts","../src/object-entries.ts","../src/focus-parser.ts","../src/step-parser.ts"],"sourcesContent":["import { diffLines } from \"diff\";\n\nString.prototype.trimEnd =\n  String.prototype.trimEnd ||\n  function(this: string) {\n    if (String.prototype.trimRight) {\n      return this.trimRight();\n    } else {\n      const trimmed = this.trim();\n      const indexOfWord = this.indexOf(trimmed);\n\n      return this.slice(indexOfWord, this.length);\n    }\n  };\n\nfunction getChanges(oldCode: string, newCode: string) {\n  const changes = diffLines(normalize(oldCode), normalize(newCode));\n  let index = 0;\n  const chunks: { op: \"-\" | \"+\"; count: number; index: number }[] = [];\n  changes.forEach(({ count = 0, removed, added }) => {\n    if (removed) {\n      chunks.push({\n        op: \"-\",\n        count,\n        index\n      });\n    }\n\n    if (added) {\n      chunks.push({\n        op: \"+\",\n        count,\n        index\n      });\n    }\n\n    if (!removed) {\n      index += count;\n    }\n  });\n\n  return chunks;\n}\n\nfunction normalize(text: string) {\n  return text && text.trimEnd().concat(\"\\n\");\n}\n\nexport function generateIds(\n  lineIds: number[],\n  afterId: number = 0,\n  count: number\n) {\n  const afterIndex = lineIds.indexOf(afterId);\n  const beforeIndex = afterIndex + 1;\n  const aid = afterId || 0;\n  const bid = lineIds[beforeIndex] || 1;\n\n  const newIds = Array(count)\n    .fill(0)\n    .map((_, i) => aid + ((bid - aid) * (i + 1)) / (count + 1));\n\n  lineIds.splice(afterIndex + 1, 0, ...newIds);\n  return newIds;\n}\n\nfunction getStepIds(\n  lineIds: number[],\n  oldStepIds: number[] = [],\n  oldStepCode: string = \"\",\n  newStepCode: string = \"\"\n): number[] {\n  const changes = getChanges(oldStepCode, newStepCode);\n\n  const newStepIds = oldStepIds.slice(0);\n  changes.forEach(({ op, count, index }) => {\n    if (op === \"-\") {\n      newStepIds.splice(index, count);\n    } else {\n      const afterId = newStepIds[index - 1];\n      const newIds = generateIds(lineIds, afterId, count);\n      newStepIds.splice(index, 0, ...newIds);\n    }\n  });\n  return newStepIds;\n}\n\nexport function linesDiff(codeList: string[]) {\n  const steps: number[][] = [];\n  const lineIds: number[] = [];\n  codeList.forEach((_, i) => {\n    steps.push(getStepIds(lineIds, steps[i - 1], codeList[i - 1], codeList[i]));\n  });\n  return { lineIds, steps };\n}\n","// // https://github.com/PrismJS/prism/issues/1303#issuecomment-375353987\n// global.Prism = { disableWorkerMessageHandler: true };\n// const Prism = require(\"prismjs\");\nimport Prism from \"prismjs\";\nconst newlineRe = /\\r\\n|\\r|\\n/;\n\nexport function tokenize(code: string, lang: string) {\n  const grammar = Prism.languages[lang];\n  if (!grammar) {\n    throw new MissingGrammarError(lang);\n  }\n\n  const prismTokens = Prism.tokenize(code, Prism.languages[lang]);\n  const nestedTokens = tokenizeStrings(prismTokens);\n  const tokens = flattenTokens(nestedTokens);\n\n  let currentLine: FlatToken[] = [];\n  let currentTokenLine: string[] = [];\n  let currentTypeLine: string[] = [];\n\n  const lines = [currentLine];\n  const tokenLines = [currentTokenLine];\n  const typeLines = [currentTypeLine];\n\n  tokens.forEach(token => {\n    const contentLines = token.content.split(newlineRe);\n\n    const firstContent = contentLines.shift();\n    if (firstContent !== undefined && firstContent !== \"\") {\n      currentLine.push({ type: token.type, content: firstContent });\n      currentTokenLine.push(firstContent);\n      currentTypeLine.push(token.type);\n    }\n    contentLines.forEach(content => {\n      currentLine = [];\n      currentTokenLine = [];\n      currentTypeLine = [];\n      lines.push(currentLine);\n      tokenLines.push(currentTokenLine);\n      typeLines.push(currentTypeLine);\n      if (content !== \"\") {\n        currentLine.push({ type: token.type, content });\n        currentTokenLine.push(content);\n        currentTypeLine.push(token.type);\n      }\n    });\n  });\n  return {\n    tokens: tokenLines,\n    types: typeLines\n  };\n}\n\ntype NestedToken = {\n  type: string;\n  content: string | NestedToken[];\n};\n\nfunction tokenizeStrings(\n  prismTokens: (string | Prism.Token)[],\n  parentType = \"plain\"\n): NestedToken[] {\n  return prismTokens.map(prismToken => wrapToken(prismToken, parentType));\n}\n\nfunction wrapToken(\n  prismToken: string | Prism.Token,\n  parentType = \"plain\"\n): NestedToken {\n  if (typeof prismToken === \"string\") {\n    return {\n      type: parentType,\n      content: prismToken\n    };\n  }\n\n  if (Array.isArray(prismToken.content)) {\n    return {\n      type: prismToken.type,\n      content: tokenizeStrings(prismToken.content, prismToken.type)\n    };\n  }\n\n  return wrapToken(prismToken.content, prismToken.type);\n}\n\ntype FlatToken = {\n  type: string;\n  content: string;\n};\n\n// Take a list of nested tokens\n// (token.content may contain an array of tokens)\n// and flatten it so content is always a string\n// and type the type of the leaf\nfunction flattenTokens(tokens: NestedToken[]) {\n  const flatList: FlatToken[] = [];\n  tokens.forEach(token => {\n    const { type, content } = token;\n    if (Array.isArray(content)) {\n      flatList.push(...flattenTokens(content));\n    } else {\n      flatList.push({ type, content });\n    }\n  });\n  return flatList;\n}\n\nexport class MissingGrammarError extends Error {\n  lang: string;\n  constructor(lang: string) {\n    super(`Missing syntax highlighting for language \"${lang}\"`);\n    this.lang = lang;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","export function fromEntries<K extends string | number | symbol, V>(\n  pairs: [K, V][]\n) {\n  const result = {} as Record<K, V>;\n\n  let index = -1,\n    length = pairs == null ? 0 : pairs.length;\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n\n  return result;\n}\n\nexport function toEntries<K extends string | number | symbol, V>(\n  o: Record<K, V>\n): [K, V][] {\n  const keys = Object.keys(o) as K[];\n  return keys.map(k => [k, o[k]]);\n}\n","import flat from \"array.prototype.flat\";\nimport { fromEntries } from \"./object-entries\";\n\ntype LineIndex = number;\ntype ColumnIndex = number;\n\nexport function parseFocus(focus: string) {\n  if (!focus) {\n    throw new Error(\"Focus cannot be empty\");\n  }\n\n  try {\n    const parts = focus.split(/,(?![^\\[]*\\])/g).map(parsePart);\n    return fromEntries(flat(parts));\n  } catch (error) {\n    // TODO enhance error\n    throw error;\n  }\n}\n\ntype Part = [LineIndex, true | ColumnIndex[]];\n\nfunction parsePart(part: string): Part[] {\n  // a part could be\n  // - a line number: \"2\"\n  // - a line range: \"5:9\"\n  // - a line number with a column selector: \"2[1,3:5,9]\"\n  const columnsMatch = part.match(/(\\d+)\\[(.+)\\]/);\n  if (columnsMatch) {\n    const [, line, columns] = columnsMatch;\n    const columnsList = columns.split(\",\").map(expandString);\n    const lineIndex = Number(line) - 1;\n    const columnIndexes = flat(columnsList).map(c => c - 1);\n    return [[lineIndex, columnIndexes]];\n  } else {\n    return expandString(part).map(lineNumber => [lineNumber - 1, true]);\n  }\n}\n\nfunction expandString(part: string) {\n  // Transforms something like\n  // - \"1:3\" to [1,2,3]\n  // - \"4\" to [4]\n  const [start, end] = part.split(\":\");\n\n  if (!isNaturalNumber(start)) {\n    throw new FocusNumberError(start);\n  }\n\n  const startNumber = Number(start);\n\n  if (startNumber < 1) {\n    throw new LineOrColumnNumberError();\n  }\n\n  if (!end) {\n    return [startNumber];\n  } else {\n    if (!isNaturalNumber(end)) {\n      throw new FocusNumberError(end);\n    }\n\n    const list: number[] = [];\n    for (let i = startNumber; i <= +end; i++) {\n      list.push(i);\n    }\n    return list;\n  }\n}\n\nfunction isNaturalNumber(n: any) {\n  n = n.toString(); // force the value in case it is not\n  var n1 = Math.abs(n),\n    n2 = parseInt(n, 10);\n  return !isNaN(n1) && n2 === n1 && n1.toString() === n;\n}\n\nexport function getFocusSize(focus: Record<LineIndex, true | ColumnIndex[]>) {\n  const lineIndexList = Object.keys(focus).map(k => +k);\n  const focusStart = Math.min.apply(Math, lineIndexList);\n  const focusEnd = Math.max.apply(Math, lineIndexList);\n  return {\n    focusCenter: (focusStart + focusEnd + 1) / 2,\n    focusCount: focusEnd - focusStart + 1\n  };\n}\n\nexport class LineOrColumnNumberError extends Error {\n  constructor() {\n    super(`Invalid line or column number in focus string`);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nexport class FocusNumberError extends Error {\n  number: string;\n  constructor(number: string) {\n    super(`Invalid number \"${number}\" in focus string`);\n    this.number = number;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import { linesDiff } from \"./differ\";\nimport { tokenize } from \"./tokenizer\";\nimport { parseFocus, getFocusSize } from \"./focus-parser\";\nimport { toEntries } from \"./object-entries\";\nimport { applyPatch } from \"diff\";\n\nexport function parseSteps(\n  inputSteps: {\n    code: string;\n    focus?: string;\n    lang?: string;\n    title?: string;\n    subtitle?: string;\n    showNumbers?: boolean;\n  }[]\n) {\n  if (inputSteps.length === 0) {\n    return {\n      tokens: [],\n      types: [],\n      steps: []\n    };\n  }\n\n  const { lang, showNumbers = false } = inputSteps[0];\n\n  if (!lang) {\n    throw new Error(\"Missing code language\");\n  }\n\n  const codeList = getCodeList(inputSteps);\n\n  const { lineIds, steps } = linesDiff(codeList);\n  const allTokens: string[][] = [];\n  const allTypes: string[][] = [];\n  const allSteps: {\n    lines: number[];\n    focus: Record<number, true | number[]>;\n    focusCenter: number;\n    focusCount: number;\n    longestLineIndex: number;\n    title?: string;\n    subtitle?: string;\n  }[] = [];\n\n  steps.forEach((step, i) => {\n    const code = codeList[i];\n    const { tokens, types } = tokenize(code, lang);\n    const lineKeys: number[] = [];\n    step.forEach((lineId, lineIndex) => {\n      const lineKey = lineIds.indexOf(lineId);\n      allTokens[lineKey] = tokens[lineIndex];\n      allTypes[lineKey] = types[lineIndex];\n      lineKeys.push(lineKey);\n    });\n\n    const focusString = inputSteps[i].focus;\n    const prevLineKeys = allSteps[i - 1] ? allSteps[i - 1].lines : [];\n    const focus = focusString\n      ? parseFocus(focusString)\n      : getDefaultFocus(prevLineKeys, lineKeys);\n    const { focusCenter, focusCount } = getFocusSize(focus);\n    allSteps.push({\n      lines: lineKeys,\n      focus,\n      focusCenter,\n      focusCount,\n      longestLineIndex: getLongestLineIndex(code),\n      title: inputSteps[i].title,\n      subtitle: inputSteps[i].subtitle\n    });\n  });\n\n  // split tokens into columns when needed\n  allSteps.forEach(({ lines, focus }) => {\n    toEntries(focus).forEach(([lineIndex, lineFocus]) => {\n      if (Array.isArray(lineFocus)) {\n        const lineKey = lines[lineIndex];\n        const lineTypes = allTypes[lineKey];\n        const lineTokens = allTokens[lineKey];\n        const [newTypes, newTokens] = splitIntoColumns(lineTypes, lineTokens);\n        allTypes[lineKey] = newTypes;\n        allTokens[lineKey] = newTokens;\n      }\n    });\n  });\n\n  // add empty char to empty lines\n  allTokens.forEach((line, lineKey) => {\n    if (line.length === 0) {\n      line.push(`\\u200B`);\n      allTypes[lineKey].push(\"plain\");\n    }\n  });\n\n  // get the line count from the step with more lines\n  const maxLineCount = allSteps.reduce(\n    (max, step) => (step.lines.length > max ? step.lines.length : max),\n    0\n  );\n\n  return {\n    tokens: allTokens,\n    types: allTypes,\n    steps: allSteps,\n    maxLineCount,\n    showNumbers\n  };\n}\n\nfunction getCodeList(\n  inputSteps: {\n    code: string;\n    lang?: string | undefined;\n  }[]\n) {\n  const firstLang = inputSteps[0].lang;\n  if (firstLang === \"diff\") {\n    return inputSteps.map(s => s.code);\n  }\n\n  let prevCode = \"\";\n  return inputSteps.map(({ code, lang }) => {\n    let stepCode = lang === \"diff\" ? applyPatch(prevCode, code) : code;\n    prevCode = stepCode;\n    return stepCode;\n  });\n}\n\nfunction splitIntoColumns(\n  types: string[],\n  tokens: string[]\n): [string[], string[]] {\n  const newTypes: string[] = [];\n  const newTokens: string[] = [];\n  tokens.forEach((token, i) => {\n    const tokenType = types[i];\n    Array.from(token).forEach(char => {\n      newTokens.push(char);\n      newTypes.push(tokenType);\n    });\n  });\n  return [newTypes, newTokens];\n}\n\nfunction getDefaultFocus(prevLineKeys: number[], lineKeys: number[]) {\n  const focus = {} as Record<number, true>;\n  lineKeys.forEach((lineKey, lineIndex) => {\n    if (!prevLineKeys.includes(lineKey)) {\n      focus[lineIndex] = true;\n    }\n  });\n\n  if (Object.keys(focus).length === 0) {\n    lineKeys.forEach((_, lineIndex) => {\n      focus[lineIndex] = true;\n    });\n  }\n\n  return focus;\n}\n\nfunction getLongestLineIndex(code: string) {\n  const newlineRe = /\\r\\n|\\r|\\n/;\n  const lines = code.split(newlineRe);\n\n  let longest = 0;\n  lines.forEach((line, i) => {\n    if (lines[longest].length < line.length) {\n      longest = i;\n    }\n  });\n\n  return longest;\n}\n"],"names":["String","prototype","trimEnd","trimRight","trimmed","trim","indexOfWord","indexOf","slice","length","getChanges","oldCode","newCode","changes","diffLines","normalize","index","chunks","forEach","count","removed","added","push","op","text","concat","generateIds","lineIds","afterId","afterIndex","beforeIndex","aid","bid","newIds","Array","fill","map","_","i","splice","getStepIds","oldStepIds","oldStepCode","newStepCode","newStepIds","linesDiff","codeList","steps","newlineRe","tokenize","code","lang","grammar","Prism","languages","MissingGrammarError","prismTokens","nestedTokens","tokenizeStrings","tokens","flattenTokens","currentLine","currentTokenLine","currentTypeLine","tokenLines","typeLines","token","contentLines","content","split","firstContent","shift","undefined","type","lines","types","parentType","prismToken","wrapToken","isArray","flatList","Object","setPrototypeOf","Error","fromEntries","pairs","result","pair","toEntries","o","keys","k","parseFocus","focus","parts","parsePart","flat","error","part","columnsMatch","match","line","columns","columnsList","expandString","lineIndex","Number","columnIndexes","c","lineNumber","start","end","isNaturalNumber","FocusNumberError","startNumber","LineOrColumnNumberError","list","n","toString","n1","Math","abs","n2","parseInt","isNaN","getFocusSize","lineIndexList","focusStart","min","apply","focusEnd","max","focusCenter","focusCount","number","parseSteps","inputSteps","showNumbers","getCodeList","allTokens","allTypes","allSteps","step","lineKeys","lineId","lineKey","focusString","prevLineKeys","getDefaultFocus","longestLineIndex","getLongestLineIndex","title","subtitle","lineFocus","lineTypes","lineTokens","splitIntoColumns","newTypes","newTokens","maxLineCount","reduce","firstLang","s","prevCode","stepCode","applyPatch","tokenType","from","char","includes","longest"],"mappings":"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"}