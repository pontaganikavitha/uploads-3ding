import { diffLines, applyPatch } from 'diff';
import Prism from 'prismjs';
import flat from 'array.prototype.flat';

String.prototype.trimEnd = String.prototype.trimEnd || function () {
  if (String.prototype.trimRight) {
    return this.trimRight();
  } else {
    var trimmed = this.trim();
    var indexOfWord = this.indexOf(trimmed);
    return this.slice(indexOfWord, this.length);
  }
};

function getChanges(oldCode, newCode) {
  var changes = diffLines(normalize(oldCode), normalize(newCode));
  var index = 0;
  var chunks = [];
  changes.forEach(function (_ref) {
    var _ref$count = _ref.count,
        count = _ref$count === void 0 ? 0 : _ref$count,
        removed = _ref.removed,
        added = _ref.added;

    if (removed) {
      chunks.push({
        op: "-",
        count: count,
        index: index
      });
    }

    if (added) {
      chunks.push({
        op: "+",
        count: count,
        index: index
      });
    }

    if (!removed) {
      index += count;
    }
  });
  return chunks;
}

function normalize(text) {
  return text && text.trimEnd().concat("\n");
}

function generateIds(lineIds, afterId, count) {
  if (afterId === void 0) {
    afterId = 0;
  }

  var afterIndex = lineIds.indexOf(afterId);
  var beforeIndex = afterIndex + 1;
  var aid = afterId || 0;
  var bid = lineIds[beforeIndex] || 1;
  var newIds = Array(count).fill(0).map(function (_, i) {
    return aid + (bid - aid) * (i + 1) / (count + 1);
  });
  lineIds.splice.apply(lineIds, [afterIndex + 1, 0].concat(newIds));
  return newIds;
}

function getStepIds(lineIds, oldStepIds, oldStepCode, newStepCode) {
  if (oldStepIds === void 0) {
    oldStepIds = [];
  }

  if (oldStepCode === void 0) {
    oldStepCode = "";
  }

  if (newStepCode === void 0) {
    newStepCode = "";
  }

  var changes = getChanges(oldStepCode, newStepCode);
  var newStepIds = oldStepIds.slice(0);
  changes.forEach(function (_ref2) {
    var op = _ref2.op,
        count = _ref2.count,
        index = _ref2.index;

    if (op === "-") {
      newStepIds.splice(index, count);
    } else {
      var afterId = newStepIds[index - 1];
      var newIds = generateIds(lineIds, afterId, count);
      newStepIds.splice.apply(newStepIds, [index, 0].concat(newIds));
    }
  });
  return newStepIds;
}

function linesDiff(codeList) {
  var steps = [];
  var lineIds = [];
  codeList.forEach(function (_, i) {
    steps.push(getStepIds(lineIds, steps[i - 1], codeList[i - 1], codeList[i]));
  });
  return {
    lineIds: lineIds,
    steps: steps
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var newlineRe = /\r\n|\r|\n/;
function tokenize(code, lang) {
  var grammar = Prism.languages[lang];

  if (!grammar) {
    throw new MissingGrammarError(lang);
  }

  var prismTokens = Prism.tokenize(code, Prism.languages[lang]);
  var nestedTokens = tokenizeStrings(prismTokens);
  var tokens = flattenTokens(nestedTokens);
  var currentLine = [];
  var currentTokenLine = [];
  var currentTypeLine = [];
  var tokenLines = [currentTokenLine];
  var typeLines = [currentTypeLine];
  tokens.forEach(function (token) {
    var contentLines = token.content.split(newlineRe);
    var firstContent = contentLines.shift();

    if (firstContent !== undefined && firstContent !== "") {
      currentLine.push({
        type: token.type,
        content: firstContent
      });
      currentTokenLine.push(firstContent);
      currentTypeLine.push(token.type);
    }

    contentLines.forEach(function (content) {
      currentLine = [];
      currentTokenLine = [];
      currentTypeLine = [];
      tokenLines.push(currentTokenLine);
      typeLines.push(currentTypeLine);

      if (content !== "") {
        currentLine.push({
          type: token.type,
          content: content
        });
        currentTokenLine.push(content);
        currentTypeLine.push(token.type);
      }
    });
  });
  return {
    tokens: tokenLines,
    types: typeLines
  };
}

function tokenizeStrings(prismTokens, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  return prismTokens.map(function (prismToken) {
    return wrapToken(prismToken, parentType);
  });
}

function wrapToken(prismToken, parentType) {
  if (parentType === void 0) {
    parentType = "plain";
  }

  if (typeof prismToken === "string") {
    return {
      type: parentType,
      content: prismToken
    };
  }

  if (Array.isArray(prismToken.content)) {
    return {
      type: prismToken.type,
      content: tokenizeStrings(prismToken.content, prismToken.type)
    };
  }

  return wrapToken(prismToken.content, prismToken.type);
} // Take a list of nested tokens
// (token.content may contain an array of tokens)
// and flatten it so content is always a string
// and type the type of the leaf


function flattenTokens(tokens) {
  var flatList = [];
  tokens.forEach(function (token) {
    var type = token.type,
        content = token.content;

    if (Array.isArray(content)) {
      flatList.push.apply(flatList, flattenTokens(content));
    } else {
      flatList.push({
        type: type,
        content: content
      });
    }
  });
  return flatList;
}

var MissingGrammarError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(MissingGrammarError, _Error);

  function MissingGrammarError(lang) {
    var _this;

    _this = _Error.call(this, "Missing syntax highlighting for language \"" + lang + "\"") || this;
    _this.lang = lang;
    Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof MissingGrammarError ? this.constructor : void 0).prototype);
    return _this;
  }

  return MissingGrammarError;
}(_wrapNativeSuper(Error));

function fromEntries(pairs) {
  var result = {};
  var index = -1,
      length = pairs == null ? 0 : pairs.length;

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }

  return result;
}
function toEntries(o) {
  var keys = Object.keys(o);
  return keys.map(function (k) {
    return [k, o[k]];
  });
}

function parseFocus(focus) {
  if (!focus) {
    throw new Error("Focus cannot be empty");
  }

  try {
    var parts = focus.split(/,(?![^\[]*\])/g).map(parsePart);
    return fromEntries(flat(parts));
  } catch (error) {
    // TODO enhance error
    throw error;
  }
}

function parsePart(part) {
  // a part could be
  // - a line number: "2"
  // - a line range: "5:9"
  // - a line number with a column selector: "2[1,3:5,9]"
  var columnsMatch = part.match(/(\d+)\[(.+)\]/);

  if (columnsMatch) {
    var line = columnsMatch[1],
        columns = columnsMatch[2];
    var columnsList = columns.split(",").map(expandString);
    var lineIndex = Number(line) - 1;
    var columnIndexes = flat(columnsList).map(function (c) {
      return c - 1;
    });
    return [[lineIndex, columnIndexes]];
  } else {
    return expandString(part).map(function (lineNumber) {
      return [lineNumber - 1, true];
    });
  }
}

function expandString(part) {
  // Transforms something like
  // - "1:3" to [1,2,3]
  // - "4" to [4]
  var _part$split = part.split(":"),
      start = _part$split[0],
      end = _part$split[1];

  if (!isNaturalNumber(start)) {
    throw new FocusNumberError(start);
  }

  var startNumber = Number(start);

  if (startNumber < 1) {
    throw new LineOrColumnNumberError();
  }

  if (!end) {
    return [startNumber];
  } else {
    if (!isNaturalNumber(end)) {
      throw new FocusNumberError(end);
    }

    var list = [];

    for (var i = startNumber; i <= +end; i++) {
      list.push(i);
    }

    return list;
  }
}

function isNaturalNumber(n) {
  n = n.toString(); // force the value in case it is not

  var n1 = Math.abs(n),
      n2 = parseInt(n, 10);
  return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}

function getFocusSize(focus) {
  var lineIndexList = Object.keys(focus).map(function (k) {
    return +k;
  });
  var focusStart = Math.min.apply(Math, lineIndexList);
  var focusEnd = Math.max.apply(Math, lineIndexList);
  return {
    focusCenter: (focusStart + focusEnd + 1) / 2,
    focusCount: focusEnd - focusStart + 1
  };
}
var LineOrColumnNumberError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(LineOrColumnNumberError, _Error);

  function LineOrColumnNumberError() {
    var _this;

    _this = _Error.call(this, "Invalid line or column number in focus string") || this;
    Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof LineOrColumnNumberError ? this.constructor : void 0).prototype);
    return _this;
  }

  return LineOrColumnNumberError;
}(_wrapNativeSuper(Error));
var FocusNumberError =
/*#__PURE__*/
function (_Error2) {
  _inheritsLoose(FocusNumberError, _Error2);

  function FocusNumberError(number) {
    var _this2;

    _this2 = _Error2.call(this, "Invalid number \"" + number + "\" in focus string") || this;
    _this2.number = number;
    Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof FocusNumberError ? this.constructor : void 0).prototype);
    return _this2;
  }

  return FocusNumberError;
}(_wrapNativeSuper(Error));

function parseSteps(inputSteps) {
  if (inputSteps.length === 0) {
    return {
      tokens: [],
      types: [],
      steps: []
    };
  }

  var _inputSteps$ = inputSteps[0],
      lang = _inputSteps$.lang,
      _inputSteps$$showNumb = _inputSteps$.showNumbers,
      showNumbers = _inputSteps$$showNumb === void 0 ? false : _inputSteps$$showNumb;

  if (!lang) {
    throw new Error("Missing code language");
  }

  var codeList = getCodeList(inputSteps);

  var _linesDiff = linesDiff(codeList),
      lineIds = _linesDiff.lineIds,
      steps = _linesDiff.steps;

  var allTokens = [];
  var allTypes = [];
  var allSteps = [];
  steps.forEach(function (step, i) {
    var code = codeList[i];

    var _tokenize = tokenize(code, lang),
        tokens = _tokenize.tokens,
        types = _tokenize.types;

    var lineKeys = [];
    step.forEach(function (lineId, lineIndex) {
      var lineKey = lineIds.indexOf(lineId);
      allTokens[lineKey] = tokens[lineIndex];
      allTypes[lineKey] = types[lineIndex];
      lineKeys.push(lineKey);
    });
    var focusString = inputSteps[i].focus;
    var prevLineKeys = allSteps[i - 1] ? allSteps[i - 1].lines : [];
    var focus = focusString ? parseFocus(focusString) : getDefaultFocus(prevLineKeys, lineKeys);

    var _getFocusSize = getFocusSize(focus),
        focusCenter = _getFocusSize.focusCenter,
        focusCount = _getFocusSize.focusCount;

    allSteps.push({
      lines: lineKeys,
      focus: focus,
      focusCenter: focusCenter,
      focusCount: focusCount,
      longestLineIndex: getLongestLineIndex(code),
      title: inputSteps[i].title,
      subtitle: inputSteps[i].subtitle
    });
  }); // split tokens into columns when needed

  allSteps.forEach(function (_ref) {
    var lines = _ref.lines,
        focus = _ref.focus;
    toEntries(focus).forEach(function (_ref2) {
      var lineIndex = _ref2[0],
          lineFocus = _ref2[1];

      if (Array.isArray(lineFocus)) {
        var lineKey = lines[lineIndex];
        var lineTypes = allTypes[lineKey];
        var lineTokens = allTokens[lineKey];

        var _splitIntoColumns = splitIntoColumns(lineTypes, lineTokens),
            newTypes = _splitIntoColumns[0],
            newTokens = _splitIntoColumns[1];

        allTypes[lineKey] = newTypes;
        allTokens[lineKey] = newTokens;
      }
    });
  }); // add empty char to empty lines

  allTokens.forEach(function (line, lineKey) {
    if (line.length === 0) {
      line.push("\u200B");
      allTypes[lineKey].push("plain");
    }
  }); // get the line count from the step with more lines

  var maxLineCount = allSteps.reduce(function (max, step) {
    return step.lines.length > max ? step.lines.length : max;
  }, 0);
  return {
    tokens: allTokens,
    types: allTypes,
    steps: allSteps,
    maxLineCount: maxLineCount,
    showNumbers: showNumbers
  };
}

function getCodeList(inputSteps) {
  var firstLang = inputSteps[0].lang;

  if (firstLang === "diff") {
    return inputSteps.map(function (s) {
      return s.code;
    });
  }

  var prevCode = "";
  return inputSteps.map(function (_ref3) {
    var code = _ref3.code,
        lang = _ref3.lang;
    var stepCode = lang === "diff" ? applyPatch(prevCode, code) : code;
    prevCode = stepCode;
    return stepCode;
  });
}

function splitIntoColumns(types, tokens) {
  var newTypes = [];
  var newTokens = [];
  tokens.forEach(function (token, i) {
    var tokenType = types[i];
    Array.from(token).forEach(function (_char) {
      newTokens.push(_char);
      newTypes.push(tokenType);
    });
  });
  return [newTypes, newTokens];
}

function getDefaultFocus(prevLineKeys, lineKeys) {
  var focus = {};
  lineKeys.forEach(function (lineKey, lineIndex) {
    if (!prevLineKeys.includes(lineKey)) {
      focus[lineIndex] = true;
    }
  });

  if (Object.keys(focus).length === 0) {
    lineKeys.forEach(function (_, lineIndex) {
      focus[lineIndex] = true;
    });
  }

  return focus;
}

function getLongestLineIndex(code) {
  var newlineRe = /\r\n|\r|\n/;
  var lines = code.split(newlineRe);
  var longest = 0;
  lines.forEach(function (line, i) {
    if (lines[longest].length < line.length) {
      longest = i;
    }
  });
  return longest;
}

export { parseSteps };
//# sourceMappingURL=step-parser.esm.js.map
