import { ATN } from 'antlr4';
import { CharStream } from 'antlr4';
import { DFA } from 'antlr4';
import { DimensionReturnType } from './visitor-return-types';
import { ErrorListener } from 'antlr4';
import { FailedPredicateException } from 'antlr4';
import { IdentifierReturnType } from './visitor-return-types';
import { Lexer } from 'antlr4';
import { Parser } from 'antlr4';
import { ParserRuleContext } from 'antlr4';
import { ParseTree } from 'antlr4';
import { ParseTreeListener } from 'antlr4';
import { ParseTreeVisitor } from 'antlr4';
import { Recognizer } from 'antlr4';
import { ReturnTypes } from './visitor-return-types';
import { RuleContext } from 'antlr4';
import { RuleNode } from 'antlr4';
import { TerminalNode } from 'antlr4';
import { Token } from 'antlr4';
import { TokenStream } from 'antlr4';
import { ValidDataType } from './interpreter-types';

declare class AccessorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    index(): IndexContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ActualParameterContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    parameterwidth_list(): ParameterwidthContext[];
    parameterwidth(i: number): ParameterwidthContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class AdditiveoperatorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PLUS(): TerminalNode;
    MINUS(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ArrayTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    ARRAY(): TerminalNode;
    LBRACK(): TerminalNode;
    typeList(): TypeListContext;
    RBRACK(): TerminalNode;
    OF(): TerminalNode;
    componentType(): ComponentTypeContext;
    LBRACK2(): TerminalNode;
    RBRACK2(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class AssignationFunctionDeclarationContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    FUNCTION(): TerminalNode;
    identifier_list(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    ASSIGN(): TerminalNode;
    block(): BlockContext;
    ENDFUNCTION(): TerminalNode;
    formalParameterList(): FormalParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class AssignmentStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    variable(): VariableContext;
    ASSIGN(): TerminalNode;
    expression(): ExpressionContext;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BaseTermContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    signedFactor(): SignedFactorContext;
    baseTerm_list(): BaseTermContext[];
    baseTerm(i: number): BaseTermContext;
    exponentiationOperator(): ExponentiationOperatorContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BaseTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    simpleType(): SimpleTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BlockContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    labelDeclarationPart_list(): LabelDeclarationPartContext[];
    labelDeclarationPart(i: number): LabelDeclarationPartContext;
    constantDefinitionPart_list(): ConstantDefinitionPartContext[];
    constantDefinitionPart(i: number): ConstantDefinitionPartContext;
    typeDefinitionPart_list(): TypeDefinitionPartContext[];
    typeDefinitionPart(i: number): TypeDefinitionPartContext;
    variableDeclarationPart_list(): VariableDeclarationPartContext[];
    variableDeclarationPart(i: number): VariableDeclarationPartContext;
    dimensionStatement_list(): DimensionStatementContext[];
    dimensionStatement(i: number): DimensionStatementContext;
    procedureAndFunctionDeclarationPart_list(): ProcedureAndFunctionDeclarationPartContext[];
    procedureAndFunctionDeclarationPart(i: number): ProcedureAndFunctionDeclarationPartContext;
    usesUnitsPart_list(): UsesUnitsPartContext[];
    usesUnitsPart(i: number): UsesUnitsPartContext;
    IMPLEMENTATION_list(): TerminalNode[];
    IMPLEMENTATION(i: number): TerminalNode;
    statements_list(): StatementsContext[];
    statements(i: number): StatementsContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class Bool_Context extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    TRUE(): TerminalNode;
    FALSE(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BooleanMultiplicativeExpressionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    booleanRelationalExpression(): BooleanRelationalExpressionContext;
    booleanMultiplicativeExpression_list(): BooleanMultiplicativeExpressionContext[];
    booleanMultiplicativeExpression(i: number): BooleanMultiplicativeExpressionContext;
    AND(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BooleanRelationalExpressionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    simpleExpression(): SimpleExpressionContext;
    booleanRelationalExpression_list(): BooleanRelationalExpressionContext[];
    booleanRelationalExpression(i: number): BooleanRelationalExpressionContext;
    relationaloperator(): RelationaloperatorContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class BreakStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    BREAK(): TerminalNode;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class CaseListElementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    constList(): ConstListContext;
    compoundStatement(): CompoundStatementContext;
    COLON(): TerminalNode;
    AS(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class CaseOtherWiseContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    compoundStatement(): CompoundStatementContext;
    ELSE(): TerminalNode;
    OTHERWISE(): TerminalNode;
    COLON(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class CaseStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    CASE(): TerminalNode;
    expression(): ExpressionContext;
    ENDCASE(): TerminalNode;
    OF(): TerminalNode;
    HACER(): TerminalNode;
    caseListElement_list(): CaseListElementContext[];
    caseListElement(i: number): CaseListElementContext;
    caseOtherWise(): CaseOtherWiseContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare class CollectorErrorListener extends ErrorListener<Token> {
    private errors;
    constructor();
    syntaxError(_recognizer: Recognizer<Token>, offendingSymbol: Token, line: number, column: number, msg: string, _e: any): void;
    getErrors(): StepCodeError[];
}

declare class ComponentTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    type_(): Type_Context;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class CompoundStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    statements_list(): StatementsContext[];
    statements(i: number): StatementsContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConditionalStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    ifStatement(): IfStatementContext;
    caseStatement(): CaseStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConstantChrContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    CHR(): TerminalNode;
    LPAREN(): TerminalNode;
    unsignedInteger(): UnsignedIntegerContext;
    RPAREN(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConstantContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    unsignedNumber(): UnsignedNumberContext;
    sign(): SignContext;
    identifier(): IdentifierContext;
    string_(): StringContext;
    constantChr(): ConstantChrContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConstantDefinitionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    EQUAL(): TerminalNode;
    constant(): ConstantContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConstantDefinitionPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    CONST(): TerminalNode;
    constantDefinition_list(): ConstantDefinitionContext[];
    constantDefinition(i: number): ConstantDefinitionContext;
    SEMI_list(): TerminalNode[];
    SEMI(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ConstListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    constant_list(): ConstantContext[];
    constant(i: number): ConstantContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ContinueStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    CONTINUE(): TerminalNode;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare function createLexer(code: string): StepCodeLexer;

export declare function createNDArray(shape: number[], type: ValidDataType): {
    array: any[];
    type: string;
};

export declare function createParser(code: string): StepCodeParser;

export declare function createParserFromLexer(lexer: StepCodeLexer): StepCodeParser;

export declare function createTokens(code: string): Token[];

declare class DimensionStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    DIMENSION(): TerminalNode;
    identifier(): IdentifierContext;
    dimensionType(): DimensionTypeContext;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class DimensionTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LBRACK(): TerminalNode;
    unsignedNumber_list(): UnsignedNumberContext[];
    unsignedNumber(i: number): UnsignedNumberContext;
    RBRACK(): TerminalNode;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class DirectivesContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    DIRECTIVE(): TerminalNode;
    IDENT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ElementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    DOTDOT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ElementListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    element_list(): ElementContext[];
    element(i: number): ElementContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ElifStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    ELIF(): TerminalNode;
    expression(): ExpressionContext;
    THEN(): TerminalNode;
    compoundStatement(): CompoundStatementContext;
    elifStatement(): ElifStatementContext;
    ENDIF(): TerminalNode;
    elseStatement(): ElseStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ElseStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    ELSE(): TerminalNode;
    compoundStatement(): CompoundStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class Empty_Context extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class EmptyStatement_Context extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare class EventBus {
    private listeners;
    constructor();
    on(event: string, callback: Function): void;
    emit(event: string, ...args: any[]): void;
}

declare class ExponentiationOperatorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    POWER(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ExpressionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    booleanMultiplicativeExpression(): BooleanMultiplicativeExpressionContext;
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    OR(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FactorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    variable(): VariableContext;
    LPAREN(): TerminalNode;
    expression(): ExpressionContext;
    RPAREN(): TerminalNode;
    functionDesignator(): FunctionDesignatorContext;
    unsignedConstant(): UnsignedConstantContext;
    set_(): Set_Context;
    NOT(): TerminalNode;
    factor(): FactorContext;
    bool_(): Bool_Context;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FieldListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    fixedPart(): FixedPartContext;
    SEMI(): TerminalNode;
    variantPart(): VariantPartContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FileTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    FILE(): TerminalNode;
    OF(): TerminalNode;
    type_(): Type_Context;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FinalValueContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FixedPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    recordSection_list(): RecordSectionContext[];
    recordSection(i: number): RecordSectionContext;
    SEMI_list(): TerminalNode[];
    SEMI(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ForListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    initialValue(): InitialValueContext;
    finalValue(): FinalValueContext;
    TO(): TerminalNode;
    DOWNTO(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FormalParameterListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LPAREN(): TerminalNode;
    formalParameterSection(): FormalParameterSectionContext;
    RPAREN(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FormalParameterSectionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    paramIdentifier_list(): ParamIdentifierContext[];
    paramIdentifier(i: number): ParamIdentifierContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ForStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    FOR(): TerminalNode;
    identifier(): IdentifierContext;
    ASSIGN(): TerminalNode;
    forList(): ForListContext;
    compoundStatement(): CompoundStatementContext;
    ENDFOR(): TerminalNode;
    DO(): TerminalNode;
    HACER(): TerminalNode;
    WITHSTEP(): TerminalNode;
    stepValue(): StepValueContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FunctionDeclarationContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    FUNCTION(): TerminalNode;
    identifier(): IdentifierContext;
    COLON(): TerminalNode;
    resultType(): ResultTypeContext;
    block(): BlockContext;
    ENDFUNCTION(): TerminalNode;
    formalParameterList(): FormalParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FunctionDesignatorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    LPAREN(): TerminalNode;
    RPAREN(): TerminalNode;
    parameterList(): ParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class FunctionTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    FUNCTION(): TerminalNode;
    COLON(): TerminalNode;
    resultType(): ResultTypeContext;
    formalParameterList(): FormalParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare function getInterpreterType(type: string): ValidDataType;

declare class GotoStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    GOTO(): TerminalNode;
    label(): LabelContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class IdentifierContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    IDENT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class IdentifierListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier_list(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class IfStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    IF(): TerminalNode;
    expression(): ExpressionContext;
    THEN(): TerminalNode;
    compoundStatement(): CompoundStatementContext;
    ENDIF(): TerminalNode;
    elifStatement(): ElifStatementContext;
    elseStatement(): ElseStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class IndexContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LBRACK(): TerminalNode;
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    RBRACK(): TerminalNode;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class IndexTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    simpleType(): SimpleTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class InitialValueContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare function interpret({ code, ...props }: InterpretProps): Promise<void>;

declare type InterpretBaseProps = {
    code: string;
    eventBus: EventBus;
};

export declare type InterpretProps = InterpretBaseProps | InterpretWithLexerProps | InterpretWithInterpreterProps | InterpretWithParserProps;

declare type InterpretWithInterpreterProps = {
    code: string;
    interpreter: StepCodeInterpreter;
};

declare type InterpretWithLexerProps = InterpretBaseProps & {
    lexer: StepCodeLexer;
    eventBus: EventBus;
};

declare type InterpretWithParserProps = InterpretBaseProps & {
    parser: StepCodeParser;
};

export declare function isCompatibleType(expected: ValidDataType, actual: ValidDataType): boolean;

export declare function isStructuredType(type: ValidDataType): boolean;

declare class LabelContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    unsignedInteger(): UnsignedIntegerContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class LabelDeclarationPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LABEL(): TerminalNode;
    label_list(): LabelContext[];
    label(i: number): LabelContext;
    SEMI(): TerminalNode;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class MainContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    programHeading(): ProgramHeadingContext;
    block(): BlockContext;
    ENDPROGRAM(): TerminalNode;
    INTERFACE(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class MultiplicativeoperatorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    STAR(): TerminalNode;
    SLASH(): TerminalNode;
    DIV(): TerminalNode;
    MOD(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ParameterListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    actualParameter_list(): ActualParameterContext[];
    actualParameter(i: number): ActualParameterContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ParameterwidthContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    COLON(): TerminalNode;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ParamIdentifierContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    typeIdentifier(): TypeIdentifierContext;
    COLON(): TerminalNode;
    AS(): TerminalNode;
    BYVALUE(): TerminalNode;
    BYREFERENCE(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare function parseTree(code: string): ProgramContext;

export declare function parseValue(type: ValidDataType, value: string): any;

declare class PointerTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    POINTER(): TerminalNode;
    typeIdentifier(): TypeIdentifierContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProcedureAndFunctionDeclarationPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    procedureOrFunctionDeclaration(): ProcedureOrFunctionDeclarationContext;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProcedureDeclarationContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PROCEDURE(): TerminalNode;
    identifier(): IdentifierContext;
    block(): BlockContext;
    ENDPROCEDURE(): TerminalNode;
    formalParameterList(): FormalParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProcedureOrFunctionDeclarationContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    procedureDeclaration(): ProcedureDeclarationContext;
    functionDeclaration(): FunctionDeclarationContext;
    assignationFunctionDeclaration(): AssignationFunctionDeclarationContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProcedureStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    LPAREN(): TerminalNode;
    RPAREN(): TerminalNode;
    parameterList(): ParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProcedureTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PROCEDURE(): TerminalNode;
    formalParameterList(): FormalParameterListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProgramContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    main(): MainContext;
    EOF(): TerminalNode;
    directives_list(): DirectivesContext[];
    directives(i: number): DirectivesContext;
    subprogram_list(): SubprogramContext[];
    subprogram(i: number): SubprogramContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ProgramHeadingContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PROGRAM(): TerminalNode;
    identifier(): IdentifierContext;
    LPAREN(): TerminalNode;
    identifierList(): IdentifierListContext;
    RPAREN(): TerminalNode;
    UNIT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare type Props = {
    startLine: number;
    startColumn: number;
    endLine: number;
    endColumn: number;
    message: string;
};

declare class ReadStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    READ(): TerminalNode;
    variable_list(): VariableContext[];
    variable(i: number): VariableContext;
    SEMI(): TerminalNode;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RecordSectionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifierList(): IdentifierListContext;
    COLON(): TerminalNode;
    type_(): Type_Context;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RecordTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    RECORD(): TerminalNode;
    END(): TerminalNode;
    fieldList(): FieldListContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RecordVariableListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    variable_list(): VariableContext[];
    variable(i: number): VariableContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RelationaloperatorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    EQUAL(): TerminalNode;
    NOT_EQUAL(): TerminalNode;
    LT(): TerminalNode;
    LE(): TerminalNode;
    GE(): TerminalNode;
    GT(): TerminalNode;
    IN(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RepeatStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    REPEAT(): TerminalNode;
    compoundStatement(): CompoundStatementContext;
    expression(): ExpressionContext;
    SEMI(): TerminalNode;
    UNTIL(): TerminalNode;
    MIENTRASQUE(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class RepetetiveStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    whileStatement(): WhileStatementContext;
    repeatStatement(): RepeatStatementContext;
    forStatement(): ForStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ResultTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    typeIdentifier(): TypeIdentifierContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ReturnStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    RETURN(): TerminalNode;
    SEMI(): TerminalNode;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class ScalarTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LPAREN(): TerminalNode;
    identifierList(): IdentifierListContext;
    RPAREN(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class Set_Context extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    LBRACK(): TerminalNode;
    elementList(): ElementListContext;
    RBRACK(): TerminalNode;
    LBRACK2(): TerminalNode;
    RBRACK2(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SetTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    SET(): TerminalNode;
    OF(): TerminalNode;
    baseType(): BaseTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SignContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PLUS(): TerminalNode;
    MINUS(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SignedFactorContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    factor(): FactorContext;
    PLUS(): TerminalNode;
    MINUS(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SimpleExpressionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    term(): TermContext;
    simpleExpression_list(): SimpleExpressionContext[];
    simpleExpression(i: number): SimpleExpressionContext;
    additiveoperator(): AdditiveoperatorContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SimpleStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    assignmentStatement(): AssignmentStatementContext;
    procedureStatement(): ProcedureStatementContext;
    gotoStatement(): GotoStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SimpleTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    scalarType(): ScalarTypeContext;
    subrangeType(): SubrangeTypeContext;
    typeIdentifier(): TypeIdentifierContext;
    stringtype(): StringtypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    unlabelledStatement(): UnlabelledStatementContext;
    writeStatement(): WriteStatementContext;
    readStatement(): ReadStatementContext;
    breakStatement(): BreakStatementContext;
    continueStatement(): ContinueStatementContext;
    returnStatement(): ReturnStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StatementsContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    statement_list(): StatementContext[];
    statement(i: number): StatementContext;
    SEMI_list(): TerminalNode[];
    SEMI(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare class StepCodeError {
    readonly startLine: number;
    readonly startColumn: number;
    readonly endLine: number;
    readonly endColumn: number;
    readonly message: string;
    constructor({ startLine, startColumn, endLine, endColumn, message }: Props);
}

export declare class StepCodeInterpreter extends StepCodeVisitor<Promise<ReturnTypes>> {
    protected eventBus: EventBus;
    protected programState: Map<string, {
        type: ValidDataType;
        value: any;
    }>;
    protected availableSubprograms: Map<string, SubprogramContext>;
    static ARRAY_START: number;
    protected callStack: {
        identifier: string;
        variables: Map<string, {
            type: ValidDataType;
            value: any;
        }>;
    }[];
    protected get variables(): Map<string, {
        type: any;
        value: any;
    }>;
    constructor(eventBus: EventBus);
    visitChildren(node: StepCodeRuleNode): Promise<ReturnTypes>;
    start(ctx: ProgramContext): Promise<void>;
    visitDirectives: (ctx: DirectivesContext) => Promise<{
        identifier: string;
    }>;
    getIndexes(ctx: AccessorContext): AsyncGenerator<ReturnTypes, void, unknown>;
    visitVariable: (ctx: VariableContext) => Promise<{
        identifier: string;
        value: any;
        type: any;
    }>;
    visitString: (ctx: StringContext) => Promise<{
        readonly identifier: string;
        readonly value: string;
        readonly type: "string";
    }>;
    visitIdentifier: (ctx: IdentifierContext) => Promise<{
        identifier: string;
    }>;
    visitType_: (ctx: Type_Context) => Promise<{
        identifier: string;
    }>;
    visitVariableDeclaration: (ctx: VariableDeclarationContext) => Promise<{
        identifier: string;
    }>;
    visitReadStatement: (ctx: ReadStatementContext) => Promise<{
        identifier: string;
    }>;
    visitWriteStatement: (ctx: WriteStatementContext) => Promise<{
        identifier: string;
    }>;
    visitUnsignedInteger: (ctx: UnsignedIntegerContext) => Promise<{
        readonly identifier: string;
        readonly value: any;
        readonly type: "integer";
    }>;
    visitUnsignedReal: (ctx: UnsignedRealContext) => Promise<{
        readonly identifier: string;
        readonly value: any;
        readonly type: "real";
    }>;
    visitSignedFactor: (ctx: SignedFactorContext) => Promise<ReturnTypes>;
    visitFactor: (ctx: FactorContext) => Promise<ReturnTypes>;
    visitBaseTerm: (ctx: BaseTermContext) => Promise<ReturnTypes>;
    visitTerm: (ctx: TermContext) => Promise<ReturnTypes>;
    visitBool_: (ctx: Bool_Context) => Promise<{
        readonly identifier: string;
        readonly value: true;
        readonly type: "boolean";
    }>;
    visitSimpleExpression: (ctx: SimpleExpressionContext) => Promise<ReturnTypes>;
    visitAssignmentStatement: (ctx: AssignmentStatementContext) => Promise<{
        identifier: string;
    }>;
    visitAdditiveoperator: (ctx: AdditiveoperatorContext) => Promise<{
        identifier: string;
    }>;
    visitBooleanRelationalExpression: (ctx: BooleanRelationalExpressionContext) => Promise<IdentifierReturnType | DimensionReturnType | {
        readonly identifier: `${string} ${string} ${string}`;
        readonly type: "boolean";
        readonly value: boolean | undefined;
    }>;
    visitBooleanMultiplicativeExpression: (ctx: BooleanMultiplicativeExpressionContext) => Promise<IdentifierReturnType | DimensionReturnType | {
        readonly identifier: `${string} AND ${string}`;
        readonly type: "boolean";
        readonly value: boolean;
    }>;
    visitExpression: (ctx: ExpressionContext) => Promise<IdentifierReturnType | DimensionReturnType | {
        readonly identifier: `${string} OR ${string}`;
        readonly type: "boolean";
        readonly value: boolean;
    }>;
    visitElifStatement: (ctx: ElifStatementContext) => Promise<ReturnTypes>;
    visitIfStatement: (ctx: IfStatementContext) => Promise<ReturnTypes>;
    visitCaseStatement: (ctx: CaseStatementContext) => Promise<ReturnTypes>;
    visitBreakStatement: () => Promise<{
        identifier: string;
    }>;
    visitContinueStatement: () => Promise<{
        identifier: string;
    }>;
    protected loopStack: RepetetiveStatementContext[];
    visitWhileStatement: (ctx: WhileStatementContext) => Promise<ReturnTypes>;
    visitForStatement: (ctx: ForStatementContext) => Promise<IdentifierReturnType | DimensionReturnType>;
    visitRepeatStatement: (ctx: RepeatStatementContext) => Promise<ReturnTypes>;
    getArgs(ctx: SubprogramContext): {
        identifier: string;
        type: string;
        reference: boolean;
    }[];
    getValueOfParameter(ctx: ActualParameterContext, byReference: boolean): Promise<{
        type: any;
        value: any;
    }>;
    visitProcedureStatement: (ctx: ProcedureStatementContext) => Promise<ReturnTypes>;
    visitFunctionDesignator: (ctx: ProcedureStatementContext) => Promise<ReturnTypes>;
    visitDimensionType: (ctx: DimensionTypeContext) => Promise<ReturnTypes>;
    visitDimensionStatement: (ctx: DimensionStatementContext) => Promise<{
        identifier: string;
    }>;
    visitSubprogram: (ctx: SubprogramContext) => Promise<ReturnTypes>;
    visitReturnStatement: (ctx: ReturnStatementContext) => Promise<{
        identifier: string;
        value: any;
        type: "string" | "boolean" | "integer" | "real" | "character";
    } | {
        identifier: string;
        value?: undefined;
        type?: undefined;
    }>;
    visitAssignationFunctionDeclaration: (ctx: AssignationFunctionDeclarationContext) => Promise<{
        identifier: string;
        value: any;
        type: any;
    }>;
}

export declare class StepCodeLexer extends Lexer {
    static readonly AND = 1;
    static readonly ARRAY = 2;
    static readonly BEGIN = 3;
    static readonly BOOLEAN = 4;
    static readonly ENDCASE = 5;
    static readonly CASE = 6;
    static readonly CHAR = 7;
    static readonly CHR = 8;
    static readonly CONST = 9;
    static readonly DIV = 10;
    static readonly DO = 11;
    static readonly DOWNTO = 12;
    static readonly ELIF = 13;
    static readonly ELSE = 14;
    static readonly OTHERWISE = 15;
    static readonly END = 16;
    static readonly FILE = 17;
    static readonly WITHSTEP = 18;
    static readonly ENDFOR = 19;
    static readonly FOR = 20;
    static readonly BYVALUE = 21;
    static readonly BYREFERENCE = 22;
    static readonly ENDFUNCTION = 23;
    static readonly FUNCTION = 24;
    static readonly GOTO = 25;
    static readonly ENDIF = 26;
    static readonly IF = 27;
    static readonly IN = 28;
    static readonly VOID = 29;
    static readonly INTEGER = 30;
    static readonly LABEL = 31;
    static readonly DIMENSION = 32;
    static readonly MOD = 33;
    static readonly NIL = 34;
    static readonly NOT = 35;
    static readonly OF = 36;
    static readonly HACER = 37;
    static readonly OR = 38;
    static readonly PACKED = 39;
    static readonly ENDPROCEDURE = 40;
    static readonly PROCEDURE = 41;
    static readonly PROGRAM = 42;
    static readonly ENDPROGRAM = 43;
    static readonly BREAK = 44;
    static readonly CONTINUE = 45;
    static readonly RETURN = 46;
    static readonly REAL = 47;
    static readonly RECORD = 48;
    static readonly REPEAT = 49;
    static readonly SET = 50;
    static readonly THEN = 51;
    static readonly UNTIL = 52;
    static readonly TO = 53;
    static readonly TYPE = 54;
    static readonly DEFINE = 55;
    static readonly ENDWHILE = 56;
    static readonly MIENTRASQUE = 57;
    static readonly WHILE = 58;
    static readonly WITH = 59;
    static readonly PLUS = 60;
    static readonly MINUS = 61;
    static readonly POWER = 62;
    static readonly STAR = 63;
    static readonly SLASH = 64;
    static readonly ASSIGN = 65;
    static readonly COMMA = 66;
    static readonly SEMI = 67;
    static readonly COLON = 68;
    static readonly EQUAL = 69;
    static readonly NOT_EQUAL = 70;
    static readonly LT = 71;
    static readonly LE = 72;
    static readonly GE = 73;
    static readonly GT = 74;
    static readonly LPAREN = 75;
    static readonly RPAREN = 76;
    static readonly LBRACK = 77;
    static readonly LBRACK2 = 78;
    static readonly RBRACK = 79;
    static readonly RBRACK2 = 80;
    static readonly POINTER = 81;
    static readonly AT = 82;
    static readonly DOT = 83;
    static readonly DOTDOT = 84;
    static readonly LCURLY = 85;
    static readonly RCURLY = 86;
    static readonly AS = 87;
    static readonly UNIT = 88;
    static readonly INTERFACE = 89;
    static readonly USES = 90;
    static readonly STRING = 91;
    static readonly IMPLEMENTATION = 92;
    static readonly TRUE = 93;
    static readonly FALSE = 94;
    static readonly WRITELN = 95;
    static readonly WRITE = 96;
    static readonly READ = 97;
    static readonly WS = 98;
    static readonly DIRECTIVE = 99;
    static readonly COMMENT_1 = 100;
    static readonly COMMENT_2 = 101;
    static readonly IDENT = 102;
    static readonly STRING_LITERAL = 103;
    static readonly NUM_INT = 104;
    static readonly NUM_REAL = 105;
    static readonly EOF: number;
    static readonly channelNames: string[];
    static readonly literalNames: (string | null)[];
    static readonly symbolicNames: (string | null)[];
    static readonly modeNames: string[];
    static readonly ruleNames: string[];
    constructor(input: CharStream);
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    get channelNames(): string[];
    get modeNames(): string[];
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): ATN;
    static DecisionsToDFA: DFA[];
}

/**
 * This interface defines a complete listener for a parse tree produced by
 * `StepCodeParser`.
 */
declare class StepCodeListener extends ParseTreeListener {
    /**
     * Enter a parse tree produced by `StepCodeParser.program`.
     * @param ctx the parse tree
     */
    enterProgram?: (ctx: ProgramContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.program`.
     * @param ctx the parse tree
     */
    exitProgram?: (ctx: ProgramContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.main`.
     * @param ctx the parse tree
     */
    enterMain?: (ctx: MainContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.main`.
     * @param ctx the parse tree
     */
    exitMain?: (ctx: MainContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.directives`.
     * @param ctx the parse tree
     */
    enterDirectives?: (ctx: DirectivesContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.directives`.
     * @param ctx the parse tree
     */
    exitDirectives?: (ctx: DirectivesContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.subprogram`.
     * @param ctx the parse tree
     */
    enterSubprogram?: (ctx: SubprogramContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.subprogram`.
     * @param ctx the parse tree
     */
    exitSubprogram?: (ctx: SubprogramContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.programHeading`.
     * @param ctx the parse tree
     */
    enterProgramHeading?: (ctx: ProgramHeadingContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.programHeading`.
     * @param ctx the parse tree
     */
    exitProgramHeading?: (ctx: ProgramHeadingContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.identifier`.
     * @param ctx the parse tree
     */
    enterIdentifier?: (ctx: IdentifierContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.identifier`.
     * @param ctx the parse tree
     */
    exitIdentifier?: (ctx: IdentifierContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.block`.
     * @param ctx the parse tree
     */
    enterBlock?: (ctx: BlockContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.block`.
     * @param ctx the parse tree
     */
    exitBlock?: (ctx: BlockContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.usesUnitsPart`.
     * @param ctx the parse tree
     */
    enterUsesUnitsPart?: (ctx: UsesUnitsPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.usesUnitsPart`.
     * @param ctx the parse tree
     */
    exitUsesUnitsPart?: (ctx: UsesUnitsPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.labelDeclarationPart`.
     * @param ctx the parse tree
     */
    enterLabelDeclarationPart?: (ctx: LabelDeclarationPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.labelDeclarationPart`.
     * @param ctx the parse tree
     */
    exitLabelDeclarationPart?: (ctx: LabelDeclarationPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.label`.
     * @param ctx the parse tree
     */
    enterLabel?: (ctx: LabelContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.label`.
     * @param ctx the parse tree
     */
    exitLabel?: (ctx: LabelContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.constantDefinitionPart`.
     * @param ctx the parse tree
     */
    enterConstantDefinitionPart?: (ctx: ConstantDefinitionPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.constantDefinitionPart`.
     * @param ctx the parse tree
     */
    exitConstantDefinitionPart?: (ctx: ConstantDefinitionPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.constantDefinition`.
     * @param ctx the parse tree
     */
    enterConstantDefinition?: (ctx: ConstantDefinitionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.constantDefinition`.
     * @param ctx the parse tree
     */
    exitConstantDefinition?: (ctx: ConstantDefinitionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.constantChr`.
     * @param ctx the parse tree
     */
    enterConstantChr?: (ctx: ConstantChrContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.constantChr`.
     * @param ctx the parse tree
     */
    exitConstantChr?: (ctx: ConstantChrContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.constant`.
     * @param ctx the parse tree
     */
    enterConstant?: (ctx: ConstantContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.constant`.
     * @param ctx the parse tree
     */
    exitConstant?: (ctx: ConstantContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unsignedNumber`.
     * @param ctx the parse tree
     */
    enterUnsignedNumber?: (ctx: UnsignedNumberContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unsignedNumber`.
     * @param ctx the parse tree
     */
    exitUnsignedNumber?: (ctx: UnsignedNumberContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unsignedInteger`.
     * @param ctx the parse tree
     */
    enterUnsignedInteger?: (ctx: UnsignedIntegerContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unsignedInteger`.
     * @param ctx the parse tree
     */
    exitUnsignedInteger?: (ctx: UnsignedIntegerContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unsignedReal`.
     * @param ctx the parse tree
     */
    enterUnsignedReal?: (ctx: UnsignedRealContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unsignedReal`.
     * @param ctx the parse tree
     */
    exitUnsignedReal?: (ctx: UnsignedRealContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.sign`.
     * @param ctx the parse tree
     */
    enterSign?: (ctx: SignContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.sign`.
     * @param ctx the parse tree
     */
    exitSign?: (ctx: SignContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.bool_`.
     * @param ctx the parse tree
     */
    enterBool_?: (ctx: Bool_Context) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.bool_`.
     * @param ctx the parse tree
     */
    exitBool_?: (ctx: Bool_Context) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.string`.
     * @param ctx the parse tree
     */
    enterString?: (ctx: StringContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.string`.
     * @param ctx the parse tree
     */
    exitString?: (ctx: StringContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.typeDefinitionPart`.
     * @param ctx the parse tree
     */
    enterTypeDefinitionPart?: (ctx: TypeDefinitionPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.typeDefinitionPart`.
     * @param ctx the parse tree
     */
    exitTypeDefinitionPart?: (ctx: TypeDefinitionPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.typeDefinition`.
     * @param ctx the parse tree
     */
    enterTypeDefinition?: (ctx: TypeDefinitionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.typeDefinition`.
     * @param ctx the parse tree
     */
    exitTypeDefinition?: (ctx: TypeDefinitionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.functionType`.
     * @param ctx the parse tree
     */
    enterFunctionType?: (ctx: FunctionTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.functionType`.
     * @param ctx the parse tree
     */
    exitFunctionType?: (ctx: FunctionTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.procedureType`.
     * @param ctx the parse tree
     */
    enterProcedureType?: (ctx: ProcedureTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.procedureType`.
     * @param ctx the parse tree
     */
    exitProcedureType?: (ctx: ProcedureTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.type_`.
     * @param ctx the parse tree
     */
    enterType_?: (ctx: Type_Context) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.type_`.
     * @param ctx the parse tree
     */
    exitType_?: (ctx: Type_Context) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.simpleType`.
     * @param ctx the parse tree
     */
    enterSimpleType?: (ctx: SimpleTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.simpleType`.
     * @param ctx the parse tree
     */
    exitSimpleType?: (ctx: SimpleTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.scalarType`.
     * @param ctx the parse tree
     */
    enterScalarType?: (ctx: ScalarTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.scalarType`.
     * @param ctx the parse tree
     */
    exitScalarType?: (ctx: ScalarTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.subrangeType`.
     * @param ctx the parse tree
     */
    enterSubrangeType?: (ctx: SubrangeTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.subrangeType`.
     * @param ctx the parse tree
     */
    exitSubrangeType?: (ctx: SubrangeTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.typeIdentifier`.
     * @param ctx the parse tree
     */
    enterTypeIdentifier?: (ctx: TypeIdentifierContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.typeIdentifier`.
     * @param ctx the parse tree
     */
    exitTypeIdentifier?: (ctx: TypeIdentifierContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.structuredType`.
     * @param ctx the parse tree
     */
    enterStructuredType?: (ctx: StructuredTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.structuredType`.
     * @param ctx the parse tree
     */
    exitStructuredType?: (ctx: StructuredTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unpackedStructuredType`.
     * @param ctx the parse tree
     */
    enterUnpackedStructuredType?: (ctx: UnpackedStructuredTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unpackedStructuredType`.
     * @param ctx the parse tree
     */
    exitUnpackedStructuredType?: (ctx: UnpackedStructuredTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.stringtype`.
     * @param ctx the parse tree
     */
    enterStringtype?: (ctx: StringtypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.stringtype`.
     * @param ctx the parse tree
     */
    exitStringtype?: (ctx: StringtypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.arrayType`.
     * @param ctx the parse tree
     */
    enterArrayType?: (ctx: ArrayTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.arrayType`.
     * @param ctx the parse tree
     */
    exitArrayType?: (ctx: ArrayTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.dimensionStatement`.
     * @param ctx the parse tree
     */
    enterDimensionStatement?: (ctx: DimensionStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.dimensionStatement`.
     * @param ctx the parse tree
     */
    exitDimensionStatement?: (ctx: DimensionStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.dimensionType`.
     * @param ctx the parse tree
     */
    enterDimensionType?: (ctx: DimensionTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.dimensionType`.
     * @param ctx the parse tree
     */
    exitDimensionType?: (ctx: DimensionTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.typeList`.
     * @param ctx the parse tree
     */
    enterTypeList?: (ctx: TypeListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.typeList`.
     * @param ctx the parse tree
     */
    exitTypeList?: (ctx: TypeListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.indexType`.
     * @param ctx the parse tree
     */
    enterIndexType?: (ctx: IndexTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.indexType`.
     * @param ctx the parse tree
     */
    exitIndexType?: (ctx: IndexTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.componentType`.
     * @param ctx the parse tree
     */
    enterComponentType?: (ctx: ComponentTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.componentType`.
     * @param ctx the parse tree
     */
    exitComponentType?: (ctx: ComponentTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.recordType`.
     * @param ctx the parse tree
     */
    enterRecordType?: (ctx: RecordTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.recordType`.
     * @param ctx the parse tree
     */
    exitRecordType?: (ctx: RecordTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.fieldList`.
     * @param ctx the parse tree
     */
    enterFieldList?: (ctx: FieldListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.fieldList`.
     * @param ctx the parse tree
     */
    exitFieldList?: (ctx: FieldListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.fixedPart`.
     * @param ctx the parse tree
     */
    enterFixedPart?: (ctx: FixedPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.fixedPart`.
     * @param ctx the parse tree
     */
    exitFixedPart?: (ctx: FixedPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.recordSection`.
     * @param ctx the parse tree
     */
    enterRecordSection?: (ctx: RecordSectionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.recordSection`.
     * @param ctx the parse tree
     */
    exitRecordSection?: (ctx: RecordSectionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.variantPart`.
     * @param ctx the parse tree
     */
    enterVariantPart?: (ctx: VariantPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.variantPart`.
     * @param ctx the parse tree
     */
    exitVariantPart?: (ctx: VariantPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.tag`.
     * @param ctx the parse tree
     */
    enterTag?: (ctx: TagContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.tag`.
     * @param ctx the parse tree
     */
    exitTag?: (ctx: TagContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.variant`.
     * @param ctx the parse tree
     */
    enterVariant?: (ctx: VariantContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.variant`.
     * @param ctx the parse tree
     */
    exitVariant?: (ctx: VariantContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.setType`.
     * @param ctx the parse tree
     */
    enterSetType?: (ctx: SetTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.setType`.
     * @param ctx the parse tree
     */
    exitSetType?: (ctx: SetTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.baseType`.
     * @param ctx the parse tree
     */
    enterBaseType?: (ctx: BaseTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.baseType`.
     * @param ctx the parse tree
     */
    exitBaseType?: (ctx: BaseTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.fileType`.
     * @param ctx the parse tree
     */
    enterFileType?: (ctx: FileTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.fileType`.
     * @param ctx the parse tree
     */
    exitFileType?: (ctx: FileTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.pointerType`.
     * @param ctx the parse tree
     */
    enterPointerType?: (ctx: PointerTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.pointerType`.
     * @param ctx the parse tree
     */
    exitPointerType?: (ctx: PointerTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.variableDeclarationPart`.
     * @param ctx the parse tree
     */
    enterVariableDeclarationPart?: (ctx: VariableDeclarationPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.variableDeclarationPart`.
     * @param ctx the parse tree
     */
    exitVariableDeclarationPart?: (ctx: VariableDeclarationPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.variableDeclaration`.
     * @param ctx the parse tree
     */
    enterVariableDeclaration?: (ctx: VariableDeclarationContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.variableDeclaration`.
     * @param ctx the parse tree
     */
    exitVariableDeclaration?: (ctx: VariableDeclarationContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.procedureAndFunctionDeclarationPart`.
     * @param ctx the parse tree
     */
    enterProcedureAndFunctionDeclarationPart?: (ctx: ProcedureAndFunctionDeclarationPartContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.procedureAndFunctionDeclarationPart`.
     * @param ctx the parse tree
     */
    exitProcedureAndFunctionDeclarationPart?: (ctx: ProcedureAndFunctionDeclarationPartContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.procedureOrFunctionDeclaration`.
     * @param ctx the parse tree
     */
    enterProcedureOrFunctionDeclaration?: (ctx: ProcedureOrFunctionDeclarationContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.procedureOrFunctionDeclaration`.
     * @param ctx the parse tree
     */
    exitProcedureOrFunctionDeclaration?: (ctx: ProcedureOrFunctionDeclarationContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.procedureDeclaration`.
     * @param ctx the parse tree
     */
    enterProcedureDeclaration?: (ctx: ProcedureDeclarationContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.procedureDeclaration`.
     * @param ctx the parse tree
     */
    exitProcedureDeclaration?: (ctx: ProcedureDeclarationContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.formalParameterList`.
     * @param ctx the parse tree
     */
    enterFormalParameterList?: (ctx: FormalParameterListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.formalParameterList`.
     * @param ctx the parse tree
     */
    exitFormalParameterList?: (ctx: FormalParameterListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.formalParameterSection`.
     * @param ctx the parse tree
     */
    enterFormalParameterSection?: (ctx: FormalParameterSectionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.formalParameterSection`.
     * @param ctx the parse tree
     */
    exitFormalParameterSection?: (ctx: FormalParameterSectionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.identifierList`.
     * @param ctx the parse tree
     */
    enterIdentifierList?: (ctx: IdentifierListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.identifierList`.
     * @param ctx the parse tree
     */
    exitIdentifierList?: (ctx: IdentifierListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.paramIdentifier`.
     * @param ctx the parse tree
     */
    enterParamIdentifier?: (ctx: ParamIdentifierContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.paramIdentifier`.
     * @param ctx the parse tree
     */
    exitParamIdentifier?: (ctx: ParamIdentifierContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.constList`.
     * @param ctx the parse tree
     */
    enterConstList?: (ctx: ConstListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.constList`.
     * @param ctx the parse tree
     */
    exitConstList?: (ctx: ConstListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.functionDeclaration`.
     * @param ctx the parse tree
     */
    enterFunctionDeclaration?: (ctx: FunctionDeclarationContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.functionDeclaration`.
     * @param ctx the parse tree
     */
    exitFunctionDeclaration?: (ctx: FunctionDeclarationContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.assignationFunctionDeclaration`.
     * @param ctx the parse tree
     */
    enterAssignationFunctionDeclaration?: (ctx: AssignationFunctionDeclarationContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.assignationFunctionDeclaration`.
     * @param ctx the parse tree
     */
    exitAssignationFunctionDeclaration?: (ctx: AssignationFunctionDeclarationContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.resultType`.
     * @param ctx the parse tree
     */
    enterResultType?: (ctx: ResultTypeContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.resultType`.
     * @param ctx the parse tree
     */
    exitResultType?: (ctx: ResultTypeContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.statement`.
     * @param ctx the parse tree
     */
    enterStatement?: (ctx: StatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.statement`.
     * @param ctx the parse tree
     */
    exitStatement?: (ctx: StatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.breakStatement`.
     * @param ctx the parse tree
     */
    enterBreakStatement?: (ctx: BreakStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.breakStatement`.
     * @param ctx the parse tree
     */
    exitBreakStatement?: (ctx: BreakStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.returnStatement`.
     * @param ctx the parse tree
     */
    enterReturnStatement?: (ctx: ReturnStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.returnStatement`.
     * @param ctx the parse tree
     */
    exitReturnStatement?: (ctx: ReturnStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.continueStatement`.
     * @param ctx the parse tree
     */
    enterContinueStatement?: (ctx: ContinueStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.continueStatement`.
     * @param ctx the parse tree
     */
    exitContinueStatement?: (ctx: ContinueStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unlabelledStatement`.
     * @param ctx the parse tree
     */
    enterUnlabelledStatement?: (ctx: UnlabelledStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unlabelledStatement`.
     * @param ctx the parse tree
     */
    exitUnlabelledStatement?: (ctx: UnlabelledStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.simpleStatement`.
     * @param ctx the parse tree
     */
    enterSimpleStatement?: (ctx: SimpleStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.simpleStatement`.
     * @param ctx the parse tree
     */
    exitSimpleStatement?: (ctx: SimpleStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.assignmentStatement`.
     * @param ctx the parse tree
     */
    enterAssignmentStatement?: (ctx: AssignmentStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.assignmentStatement`.
     * @param ctx the parse tree
     */
    exitAssignmentStatement?: (ctx: AssignmentStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.variable`.
     * @param ctx the parse tree
     */
    enterVariable?: (ctx: VariableContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.variable`.
     * @param ctx the parse tree
     */
    exitVariable?: (ctx: VariableContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.accessor`.
     * @param ctx the parse tree
     */
    enterAccessor?: (ctx: AccessorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.accessor`.
     * @param ctx the parse tree
     */
    exitAccessor?: (ctx: AccessorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.index`.
     * @param ctx the parse tree
     */
    enterIndex?: (ctx: IndexContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.index`.
     * @param ctx the parse tree
     */
    exitIndex?: (ctx: IndexContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.expression`.
     * @param ctx the parse tree
     */
    enterExpression?: (ctx: ExpressionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.expression`.
     * @param ctx the parse tree
     */
    exitExpression?: (ctx: ExpressionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.booleanMultiplicativeExpression`.
     * @param ctx the parse tree
     */
    enterBooleanMultiplicativeExpression?: (ctx: BooleanMultiplicativeExpressionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.booleanMultiplicativeExpression`.
     * @param ctx the parse tree
     */
    exitBooleanMultiplicativeExpression?: (ctx: BooleanMultiplicativeExpressionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.booleanRelationalExpression`.
     * @param ctx the parse tree
     */
    enterBooleanRelationalExpression?: (ctx: BooleanRelationalExpressionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.booleanRelationalExpression`.
     * @param ctx the parse tree
     */
    exitBooleanRelationalExpression?: (ctx: BooleanRelationalExpressionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.relationaloperator`.
     * @param ctx the parse tree
     */
    enterRelationaloperator?: (ctx: RelationaloperatorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.relationaloperator`.
     * @param ctx the parse tree
     */
    exitRelationaloperator?: (ctx: RelationaloperatorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.simpleExpression`.
     * @param ctx the parse tree
     */
    enterSimpleExpression?: (ctx: SimpleExpressionContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.simpleExpression`.
     * @param ctx the parse tree
     */
    exitSimpleExpression?: (ctx: SimpleExpressionContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.additiveoperator`.
     * @param ctx the parse tree
     */
    enterAdditiveoperator?: (ctx: AdditiveoperatorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.additiveoperator`.
     * @param ctx the parse tree
     */
    exitAdditiveoperator?: (ctx: AdditiveoperatorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.term`.
     * @param ctx the parse tree
     */
    enterTerm?: (ctx: TermContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.term`.
     * @param ctx the parse tree
     */
    exitTerm?: (ctx: TermContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.baseTerm`.
     * @param ctx the parse tree
     */
    enterBaseTerm?: (ctx: BaseTermContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.baseTerm`.
     * @param ctx the parse tree
     */
    exitBaseTerm?: (ctx: BaseTermContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.multiplicativeoperator`.
     * @param ctx the parse tree
     */
    enterMultiplicativeoperator?: (ctx: MultiplicativeoperatorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.multiplicativeoperator`.
     * @param ctx the parse tree
     */
    exitMultiplicativeoperator?: (ctx: MultiplicativeoperatorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.exponentiationOperator`.
     * @param ctx the parse tree
     */
    enterExponentiationOperator?: (ctx: ExponentiationOperatorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.exponentiationOperator`.
     * @param ctx the parse tree
     */
    exitExponentiationOperator?: (ctx: ExponentiationOperatorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.signedFactor`.
     * @param ctx the parse tree
     */
    enterSignedFactor?: (ctx: SignedFactorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.signedFactor`.
     * @param ctx the parse tree
     */
    exitSignedFactor?: (ctx: SignedFactorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.factor`.
     * @param ctx the parse tree
     */
    enterFactor?: (ctx: FactorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.factor`.
     * @param ctx the parse tree
     */
    exitFactor?: (ctx: FactorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.unsignedConstant`.
     * @param ctx the parse tree
     */
    enterUnsignedConstant?: (ctx: UnsignedConstantContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.unsignedConstant`.
     * @param ctx the parse tree
     */
    exitUnsignedConstant?: (ctx: UnsignedConstantContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.functionDesignator`.
     * @param ctx the parse tree
     */
    enterFunctionDesignator?: (ctx: FunctionDesignatorContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.functionDesignator`.
     * @param ctx the parse tree
     */
    exitFunctionDesignator?: (ctx: FunctionDesignatorContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.parameterList`.
     * @param ctx the parse tree
     */
    enterParameterList?: (ctx: ParameterListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.parameterList`.
     * @param ctx the parse tree
     */
    exitParameterList?: (ctx: ParameterListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.set_`.
     * @param ctx the parse tree
     */
    enterSet_?: (ctx: Set_Context) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.set_`.
     * @param ctx the parse tree
     */
    exitSet_?: (ctx: Set_Context) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.elementList`.
     * @param ctx the parse tree
     */
    enterElementList?: (ctx: ElementListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.elementList`.
     * @param ctx the parse tree
     */
    exitElementList?: (ctx: ElementListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.element`.
     * @param ctx the parse tree
     */
    enterElement?: (ctx: ElementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.element`.
     * @param ctx the parse tree
     */
    exitElement?: (ctx: ElementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.procedureStatement`.
     * @param ctx the parse tree
     */
    enterProcedureStatement?: (ctx: ProcedureStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.procedureStatement`.
     * @param ctx the parse tree
     */
    exitProcedureStatement?: (ctx: ProcedureStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.actualParameter`.
     * @param ctx the parse tree
     */
    enterActualParameter?: (ctx: ActualParameterContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.actualParameter`.
     * @param ctx the parse tree
     */
    exitActualParameter?: (ctx: ActualParameterContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.parameterwidth`.
     * @param ctx the parse tree
     */
    enterParameterwidth?: (ctx: ParameterwidthContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.parameterwidth`.
     * @param ctx the parse tree
     */
    exitParameterwidth?: (ctx: ParameterwidthContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.gotoStatement`.
     * @param ctx the parse tree
     */
    enterGotoStatement?: (ctx: GotoStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.gotoStatement`.
     * @param ctx the parse tree
     */
    exitGotoStatement?: (ctx: GotoStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.emptyStatement_`.
     * @param ctx the parse tree
     */
    enterEmptyStatement_?: (ctx: EmptyStatement_Context) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.emptyStatement_`.
     * @param ctx the parse tree
     */
    exitEmptyStatement_?: (ctx: EmptyStatement_Context) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.empty_`.
     * @param ctx the parse tree
     */
    enterEmpty_?: (ctx: Empty_Context) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.empty_`.
     * @param ctx the parse tree
     */
    exitEmpty_?: (ctx: Empty_Context) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.structuredStatement`.
     * @param ctx the parse tree
     */
    enterStructuredStatement?: (ctx: StructuredStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.structuredStatement`.
     * @param ctx the parse tree
     */
    exitStructuredStatement?: (ctx: StructuredStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.compoundStatement`.
     * @param ctx the parse tree
     */
    enterCompoundStatement?: (ctx: CompoundStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.compoundStatement`.
     * @param ctx the parse tree
     */
    exitCompoundStatement?: (ctx: CompoundStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.statements`.
     * @param ctx the parse tree
     */
    enterStatements?: (ctx: StatementsContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.statements`.
     * @param ctx the parse tree
     */
    exitStatements?: (ctx: StatementsContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.conditionalStatement`.
     * @param ctx the parse tree
     */
    enterConditionalStatement?: (ctx: ConditionalStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.conditionalStatement`.
     * @param ctx the parse tree
     */
    exitConditionalStatement?: (ctx: ConditionalStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.ifStatement`.
     * @param ctx the parse tree
     */
    enterIfStatement?: (ctx: IfStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.ifStatement`.
     * @param ctx the parse tree
     */
    exitIfStatement?: (ctx: IfStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.elifStatement`.
     * @param ctx the parse tree
     */
    enterElifStatement?: (ctx: ElifStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.elifStatement`.
     * @param ctx the parse tree
     */
    exitElifStatement?: (ctx: ElifStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.elseStatement`.
     * @param ctx the parse tree
     */
    enterElseStatement?: (ctx: ElseStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.elseStatement`.
     * @param ctx the parse tree
     */
    exitElseStatement?: (ctx: ElseStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.caseStatement`.
     * @param ctx the parse tree
     */
    enterCaseStatement?: (ctx: CaseStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.caseStatement`.
     * @param ctx the parse tree
     */
    exitCaseStatement?: (ctx: CaseStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.caseListElement`.
     * @param ctx the parse tree
     */
    enterCaseListElement?: (ctx: CaseListElementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.caseListElement`.
     * @param ctx the parse tree
     */
    exitCaseListElement?: (ctx: CaseListElementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.caseOtherWise`.
     * @param ctx the parse tree
     */
    enterCaseOtherWise?: (ctx: CaseOtherWiseContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.caseOtherWise`.
     * @param ctx the parse tree
     */
    exitCaseOtherWise?: (ctx: CaseOtherWiseContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.repetetiveStatement`.
     * @param ctx the parse tree
     */
    enterRepetetiveStatement?: (ctx: RepetetiveStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.repetetiveStatement`.
     * @param ctx the parse tree
     */
    exitRepetetiveStatement?: (ctx: RepetetiveStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.whileStatement`.
     * @param ctx the parse tree
     */
    enterWhileStatement?: (ctx: WhileStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.whileStatement`.
     * @param ctx the parse tree
     */
    exitWhileStatement?: (ctx: WhileStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.repeatStatement`.
     * @param ctx the parse tree
     */
    enterRepeatStatement?: (ctx: RepeatStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.repeatStatement`.
     * @param ctx the parse tree
     */
    exitRepeatStatement?: (ctx: RepeatStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.forStatement`.
     * @param ctx the parse tree
     */
    enterForStatement?: (ctx: ForStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.forStatement`.
     * @param ctx the parse tree
     */
    exitForStatement?: (ctx: ForStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.forList`.
     * @param ctx the parse tree
     */
    enterForList?: (ctx: ForListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.forList`.
     * @param ctx the parse tree
     */
    exitForList?: (ctx: ForListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.initialValue`.
     * @param ctx the parse tree
     */
    enterInitialValue?: (ctx: InitialValueContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.initialValue`.
     * @param ctx the parse tree
     */
    exitInitialValue?: (ctx: InitialValueContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.finalValue`.
     * @param ctx the parse tree
     */
    enterFinalValue?: (ctx: FinalValueContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.finalValue`.
     * @param ctx the parse tree
     */
    exitFinalValue?: (ctx: FinalValueContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.stepValue`.
     * @param ctx the parse tree
     */
    enterStepValue?: (ctx: StepValueContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.stepValue`.
     * @param ctx the parse tree
     */
    exitStepValue?: (ctx: StepValueContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.withStatement`.
     * @param ctx the parse tree
     */
    enterWithStatement?: (ctx: WithStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.withStatement`.
     * @param ctx the parse tree
     */
    exitWithStatement?: (ctx: WithStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.recordVariableList`.
     * @param ctx the parse tree
     */
    enterRecordVariableList?: (ctx: RecordVariableListContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.recordVariableList`.
     * @param ctx the parse tree
     */
    exitRecordVariableList?: (ctx: RecordVariableListContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.writeStatement`.
     * @param ctx the parse tree
     */
    enterWriteStatement?: (ctx: WriteStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.writeStatement`.
     * @param ctx the parse tree
     */
    exitWriteStatement?: (ctx: WriteStatementContext) => void;
    /**
     * Enter a parse tree produced by `StepCodeParser.readStatement`.
     * @param ctx the parse tree
     */
    enterReadStatement?: (ctx: ReadStatementContext) => void;
    /**
     * Exit a parse tree produced by `StepCodeParser.readStatement`.
     * @param ctx the parse tree
     */
    exitReadStatement?: (ctx: ReadStatementContext) => void;
}

declare class StepCodeParser extends Parser {
    static readonly AND = 1;
    static readonly ARRAY = 2;
    static readonly BEGIN = 3;
    static readonly BOOLEAN = 4;
    static readonly ENDCASE = 5;
    static readonly CASE = 6;
    static readonly CHAR = 7;
    static readonly CHR = 8;
    static readonly CONST = 9;
    static readonly DIV = 10;
    static readonly DO = 11;
    static readonly DOWNTO = 12;
    static readonly ELIF = 13;
    static readonly ELSE = 14;
    static readonly OTHERWISE = 15;
    static readonly END = 16;
    static readonly FILE = 17;
    static readonly WITHSTEP = 18;
    static readonly ENDFOR = 19;
    static readonly FOR = 20;
    static readonly BYVALUE = 21;
    static readonly BYREFERENCE = 22;
    static readonly ENDFUNCTION = 23;
    static readonly FUNCTION = 24;
    static readonly GOTO = 25;
    static readonly ENDIF = 26;
    static readonly IF = 27;
    static readonly IN = 28;
    static readonly VOID = 29;
    static readonly INTEGER = 30;
    static readonly LABEL = 31;
    static readonly DIMENSION = 32;
    static readonly MOD = 33;
    static readonly NIL = 34;
    static readonly NOT = 35;
    static readonly OF = 36;
    static readonly HACER = 37;
    static readonly OR = 38;
    static readonly PACKED = 39;
    static readonly ENDPROCEDURE = 40;
    static readonly PROCEDURE = 41;
    static readonly PROGRAM = 42;
    static readonly ENDPROGRAM = 43;
    static readonly BREAK = 44;
    static readonly CONTINUE = 45;
    static readonly RETURN = 46;
    static readonly REAL = 47;
    static readonly RECORD = 48;
    static readonly REPEAT = 49;
    static readonly SET = 50;
    static readonly THEN = 51;
    static readonly UNTIL = 52;
    static readonly TO = 53;
    static readonly TYPE = 54;
    static readonly DEFINE = 55;
    static readonly ENDWHILE = 56;
    static readonly MIENTRASQUE = 57;
    static readonly WHILE = 58;
    static readonly WITH = 59;
    static readonly PLUS = 60;
    static readonly MINUS = 61;
    static readonly POWER = 62;
    static readonly STAR = 63;
    static readonly SLASH = 64;
    static readonly ASSIGN = 65;
    static readonly COMMA = 66;
    static readonly SEMI = 67;
    static readonly COLON = 68;
    static readonly EQUAL = 69;
    static readonly NOT_EQUAL = 70;
    static readonly LT = 71;
    static readonly LE = 72;
    static readonly GE = 73;
    static readonly GT = 74;
    static readonly LPAREN = 75;
    static readonly RPAREN = 76;
    static readonly LBRACK = 77;
    static readonly LBRACK2 = 78;
    static readonly RBRACK = 79;
    static readonly RBRACK2 = 80;
    static readonly POINTER = 81;
    static readonly AT = 82;
    static readonly DOT = 83;
    static readonly DOTDOT = 84;
    static readonly LCURLY = 85;
    static readonly RCURLY = 86;
    static readonly AS = 87;
    static readonly UNIT = 88;
    static readonly INTERFACE = 89;
    static readonly USES = 90;
    static readonly STRING = 91;
    static readonly IMPLEMENTATION = 92;
    static readonly TRUE = 93;
    static readonly FALSE = 94;
    static readonly WRITELN = 95;
    static readonly WRITE = 96;
    static readonly READ = 97;
    static readonly WS = 98;
    static readonly DIRECTIVE = 99;
    static readonly COMMENT_1 = 100;
    static readonly COMMENT_2 = 101;
    static readonly IDENT = 102;
    static readonly STRING_LITERAL = 103;
    static readonly NUM_INT = 104;
    static readonly NUM_REAL = 105;
    static readonly EOF: number;
    static readonly RULE_program = 0;
    static readonly RULE_main = 1;
    static readonly RULE_directives = 2;
    static readonly RULE_subprogram = 3;
    static readonly RULE_programHeading = 4;
    static readonly RULE_identifier = 5;
    static readonly RULE_block = 6;
    static readonly RULE_usesUnitsPart = 7;
    static readonly RULE_labelDeclarationPart = 8;
    static readonly RULE_label = 9;
    static readonly RULE_constantDefinitionPart = 10;
    static readonly RULE_constantDefinition = 11;
    static readonly RULE_constantChr = 12;
    static readonly RULE_constant = 13;
    static readonly RULE_unsignedNumber = 14;
    static readonly RULE_unsignedInteger = 15;
    static readonly RULE_unsignedReal = 16;
    static readonly RULE_sign = 17;
    static readonly RULE_bool_ = 18;
    static readonly RULE_string = 19;
    static readonly RULE_typeDefinitionPart = 20;
    static readonly RULE_typeDefinition = 21;
    static readonly RULE_functionType = 22;
    static readonly RULE_procedureType = 23;
    static readonly RULE_type_ = 24;
    static readonly RULE_simpleType = 25;
    static readonly RULE_scalarType = 26;
    static readonly RULE_subrangeType = 27;
    static readonly RULE_typeIdentifier = 28;
    static readonly RULE_structuredType = 29;
    static readonly RULE_unpackedStructuredType = 30;
    static readonly RULE_stringtype = 31;
    static readonly RULE_arrayType = 32;
    static readonly RULE_dimensionStatement = 33;
    static readonly RULE_dimensionType = 34;
    static readonly RULE_typeList = 35;
    static readonly RULE_indexType = 36;
    static readonly RULE_componentType = 37;
    static readonly RULE_recordType = 38;
    static readonly RULE_fieldList = 39;
    static readonly RULE_fixedPart = 40;
    static readonly RULE_recordSection = 41;
    static readonly RULE_variantPart = 42;
    static readonly RULE_tag = 43;
    static readonly RULE_variant = 44;
    static readonly RULE_setType = 45;
    static readonly RULE_baseType = 46;
    static readonly RULE_fileType = 47;
    static readonly RULE_pointerType = 48;
    static readonly RULE_variableDeclarationPart = 49;
    static readonly RULE_variableDeclaration = 50;
    static readonly RULE_procedureAndFunctionDeclarationPart = 51;
    static readonly RULE_procedureOrFunctionDeclaration = 52;
    static readonly RULE_procedureDeclaration = 53;
    static readonly RULE_formalParameterList = 54;
    static readonly RULE_formalParameterSection = 55;
    static readonly RULE_identifierList = 56;
    static readonly RULE_paramIdentifier = 57;
    static readonly RULE_constList = 58;
    static readonly RULE_functionDeclaration = 59;
    static readonly RULE_assignationFunctionDeclaration = 60;
    static readonly RULE_resultType = 61;
    static readonly RULE_statement = 62;
    static readonly RULE_breakStatement = 63;
    static readonly RULE_returnStatement = 64;
    static readonly RULE_continueStatement = 65;
    static readonly RULE_unlabelledStatement = 66;
    static readonly RULE_simpleStatement = 67;
    static readonly RULE_assignmentStatement = 68;
    static readonly RULE_variable = 69;
    static readonly RULE_accessor = 70;
    static readonly RULE_index = 71;
    static readonly RULE_expression = 72;
    static readonly RULE_booleanMultiplicativeExpression = 73;
    static readonly RULE_booleanRelationalExpression = 74;
    static readonly RULE_relationaloperator = 75;
    static readonly RULE_simpleExpression = 76;
    static readonly RULE_additiveoperator = 77;
    static readonly RULE_term = 78;
    static readonly RULE_baseTerm = 79;
    static readonly RULE_multiplicativeoperator = 80;
    static readonly RULE_exponentiationOperator = 81;
    static readonly RULE_signedFactor = 82;
    static readonly RULE_factor = 83;
    static readonly RULE_unsignedConstant = 84;
    static readonly RULE_functionDesignator = 85;
    static readonly RULE_parameterList = 86;
    static readonly RULE_set_ = 87;
    static readonly RULE_elementList = 88;
    static readonly RULE_element = 89;
    static readonly RULE_procedureStatement = 90;
    static readonly RULE_actualParameter = 91;
    static readonly RULE_parameterwidth = 92;
    static readonly RULE_gotoStatement = 93;
    static readonly RULE_emptyStatement_ = 94;
    static readonly RULE_empty_ = 95;
    static readonly RULE_structuredStatement = 96;
    static readonly RULE_compoundStatement = 97;
    static readonly RULE_statements = 98;
    static readonly RULE_conditionalStatement = 99;
    static readonly RULE_ifStatement = 100;
    static readonly RULE_elifStatement = 101;
    static readonly RULE_elseStatement = 102;
    static readonly RULE_caseStatement = 103;
    static readonly RULE_caseListElement = 104;
    static readonly RULE_caseOtherWise = 105;
    static readonly RULE_repetetiveStatement = 106;
    static readonly RULE_whileStatement = 107;
    static readonly RULE_repeatStatement = 108;
    static readonly RULE_forStatement = 109;
    static readonly RULE_forList = 110;
    static readonly RULE_initialValue = 111;
    static readonly RULE_finalValue = 112;
    static readonly RULE_stepValue = 113;
    static readonly RULE_withStatement = 114;
    static readonly RULE_recordVariableList = 115;
    static readonly RULE_writeStatement = 116;
    static readonly RULE_readStatement = 117;
    static readonly literalNames: (string | null)[];
    static readonly symbolicNames: (string | null)[];
    static readonly ruleNames: string[];
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    protected createFailedPredicateException(predicate?: string, message?: string): FailedPredicateException;
    constructor(input: TokenStream);
    program(): ProgramContext;
    main(): MainContext;
    directives(): DirectivesContext;
    subprogram(): SubprogramContext;
    programHeading(): ProgramHeadingContext;
    identifier(): IdentifierContext;
    block(): BlockContext;
    usesUnitsPart(): UsesUnitsPartContext;
    labelDeclarationPart(): LabelDeclarationPartContext;
    label(): LabelContext;
    constantDefinitionPart(): ConstantDefinitionPartContext;
    constantDefinition(): ConstantDefinitionContext;
    constantChr(): ConstantChrContext;
    constant(): ConstantContext;
    unsignedNumber(): UnsignedNumberContext;
    unsignedInteger(): UnsignedIntegerContext;
    unsignedReal(): UnsignedRealContext;
    sign(): SignContext;
    bool_(): Bool_Context;
    string_(): StringContext;
    typeDefinitionPart(): TypeDefinitionPartContext;
    typeDefinition(): TypeDefinitionContext;
    functionType(): FunctionTypeContext;
    procedureType(): ProcedureTypeContext;
    type_(): Type_Context;
    simpleType(): SimpleTypeContext;
    scalarType(): ScalarTypeContext;
    subrangeType(): SubrangeTypeContext;
    typeIdentifier(): TypeIdentifierContext;
    structuredType(): StructuredTypeContext;
    unpackedStructuredType(): UnpackedStructuredTypeContext;
    stringtype(): StringtypeContext;
    arrayType(): ArrayTypeContext;
    dimensionStatement(): DimensionStatementContext;
    dimensionType(): DimensionTypeContext;
    typeList(): TypeListContext;
    indexType(): IndexTypeContext;
    componentType(): ComponentTypeContext;
    recordType(): RecordTypeContext;
    fieldList(): FieldListContext;
    fixedPart(): FixedPartContext;
    recordSection(): RecordSectionContext;
    variantPart(): VariantPartContext;
    tag(): TagContext;
    variant(): VariantContext;
    setType(): SetTypeContext;
    baseType(): BaseTypeContext;
    fileType(): FileTypeContext;
    pointerType(): PointerTypeContext;
    variableDeclarationPart(): VariableDeclarationPartContext;
    variableDeclaration(): VariableDeclarationContext;
    procedureAndFunctionDeclarationPart(): ProcedureAndFunctionDeclarationPartContext;
    procedureOrFunctionDeclaration(): ProcedureOrFunctionDeclarationContext;
    procedureDeclaration(): ProcedureDeclarationContext;
    formalParameterList(): FormalParameterListContext;
    formalParameterSection(): FormalParameterSectionContext;
    identifierList(): IdentifierListContext;
    paramIdentifier(): ParamIdentifierContext;
    constList(): ConstListContext;
    functionDeclaration(): FunctionDeclarationContext;
    assignationFunctionDeclaration(): AssignationFunctionDeclarationContext;
    resultType(): ResultTypeContext;
    statement(): StatementContext;
    breakStatement(): BreakStatementContext;
    returnStatement(): ReturnStatementContext;
    continueStatement(): ContinueStatementContext;
    unlabelledStatement(): UnlabelledStatementContext;
    simpleStatement(): SimpleStatementContext;
    assignmentStatement(): AssignmentStatementContext;
    variable(): VariableContext;
    accessor(): AccessorContext;
    index(): IndexContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    booleanMultiplicativeExpression(): BooleanMultiplicativeExpressionContext;
    booleanMultiplicativeExpression(_p: number): BooleanMultiplicativeExpressionContext;
    booleanRelationalExpression(): BooleanRelationalExpressionContext;
    booleanRelationalExpression(_p: number): BooleanRelationalExpressionContext;
    relationaloperator(): RelationaloperatorContext;
    simpleExpression(): SimpleExpressionContext;
    simpleExpression(_p: number): SimpleExpressionContext;
    additiveoperator(): AdditiveoperatorContext;
    term(): TermContext;
    term(_p: number): TermContext;
    baseTerm(): BaseTermContext;
    baseTerm(_p: number): BaseTermContext;
    multiplicativeoperator(): MultiplicativeoperatorContext;
    exponentiationOperator(): ExponentiationOperatorContext;
    signedFactor(): SignedFactorContext;
    factor(): FactorContext;
    unsignedConstant(): UnsignedConstantContext;
    functionDesignator(): FunctionDesignatorContext;
    parameterList(): ParameterListContext;
    set_(): Set_Context;
    elementList(): ElementListContext;
    element(): ElementContext;
    procedureStatement(): ProcedureStatementContext;
    actualParameter(): ActualParameterContext;
    parameterwidth(): ParameterwidthContext;
    gotoStatement(): GotoStatementContext;
    emptyStatement_(): EmptyStatement_Context;
    empty_(): Empty_Context;
    structuredStatement(): StructuredStatementContext;
    compoundStatement(): CompoundStatementContext;
    statements(): StatementsContext;
    conditionalStatement(): ConditionalStatementContext;
    ifStatement(): IfStatementContext;
    elifStatement(): ElifStatementContext;
    elseStatement(): ElseStatementContext;
    caseStatement(): CaseStatementContext;
    caseListElement(): CaseListElementContext;
    caseOtherWise(): CaseOtherWiseContext;
    repetetiveStatement(): RepetetiveStatementContext;
    whileStatement(): WhileStatementContext;
    repeatStatement(): RepeatStatementContext;
    forStatement(): ForStatementContext;
    forList(): ForListContext;
    initialValue(): InitialValueContext;
    finalValue(): FinalValueContext;
    stepValue(): StepValueContext;
    withStatement(): WithStatementContext;
    recordVariableList(): RecordVariableListContext;
    writeStatement(): WriteStatementContext;
    readStatement(): ReadStatementContext;
    sempred(localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    private expression_sempred;
    private booleanMultiplicativeExpression_sempred;
    private booleanRelationalExpression_sempred;
    private simpleExpression_sempred;
    private term_sempred;
    private baseTerm_sempred;
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): ATN;
    static DecisionsToDFA: DFA[];
}

export declare class StepCodeRuleNode extends RuleNode {
    children: ParseTree[] | null;
}

/**
 * This interface defines a complete generic visitor for a parse tree produced
 * by `StepCodeParser`.
 *
 * @param <Result> The return type of the visit operation. Use `void` for
 * operations with no return type.
 */
declare class StepCodeVisitor<Result> extends ParseTreeVisitor<Result> {
    /**
     * Visit a parse tree produced by `StepCodeParser.program`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProgram?: (ctx: ProgramContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.main`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitMain?: (ctx: MainContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.directives`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitDirectives?: (ctx: DirectivesContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.subprogram`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSubprogram?: (ctx: SubprogramContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.programHeading`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProgramHeading?: (ctx: ProgramHeadingContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.identifier`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitIdentifier?: (ctx: IdentifierContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.block`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBlock?: (ctx: BlockContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.usesUnitsPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUsesUnitsPart?: (ctx: UsesUnitsPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.labelDeclarationPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitLabelDeclarationPart?: (ctx: LabelDeclarationPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.label`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitLabel?: (ctx: LabelContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.constantDefinitionPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConstantDefinitionPart?: (ctx: ConstantDefinitionPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.constantDefinition`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConstantDefinition?: (ctx: ConstantDefinitionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.constantChr`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConstantChr?: (ctx: ConstantChrContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.constant`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConstant?: (ctx: ConstantContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unsignedNumber`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnsignedNumber?: (ctx: UnsignedNumberContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unsignedInteger`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnsignedInteger?: (ctx: UnsignedIntegerContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unsignedReal`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnsignedReal?: (ctx: UnsignedRealContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.sign`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSign?: (ctx: SignContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.bool_`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBool_?: (ctx: Bool_Context) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.string`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitString?: (ctx: StringContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.typeDefinitionPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTypeDefinitionPart?: (ctx: TypeDefinitionPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.typeDefinition`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTypeDefinition?: (ctx: TypeDefinitionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.functionType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFunctionType?: (ctx: FunctionTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.procedureType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProcedureType?: (ctx: ProcedureTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.type_`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitType_?: (ctx: Type_Context) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.simpleType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSimpleType?: (ctx: SimpleTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.scalarType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitScalarType?: (ctx: ScalarTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.subrangeType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSubrangeType?: (ctx: SubrangeTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.typeIdentifier`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTypeIdentifier?: (ctx: TypeIdentifierContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.structuredType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStructuredType?: (ctx: StructuredTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unpackedStructuredType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnpackedStructuredType?: (ctx: UnpackedStructuredTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.stringtype`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStringtype?: (ctx: StringtypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.arrayType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitArrayType?: (ctx: ArrayTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.dimensionStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitDimensionStatement?: (ctx: DimensionStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.dimensionType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitDimensionType?: (ctx: DimensionTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.typeList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTypeList?: (ctx: TypeListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.indexType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitIndexType?: (ctx: IndexTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.componentType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitComponentType?: (ctx: ComponentTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.recordType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRecordType?: (ctx: RecordTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.fieldList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFieldList?: (ctx: FieldListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.fixedPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFixedPart?: (ctx: FixedPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.recordSection`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRecordSection?: (ctx: RecordSectionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.variantPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitVariantPart?: (ctx: VariantPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.tag`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTag?: (ctx: TagContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.variant`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitVariant?: (ctx: VariantContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.setType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSetType?: (ctx: SetTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.baseType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBaseType?: (ctx: BaseTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.fileType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFileType?: (ctx: FileTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.pointerType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitPointerType?: (ctx: PointerTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.variableDeclarationPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitVariableDeclarationPart?: (ctx: VariableDeclarationPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.variableDeclaration`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitVariableDeclaration?: (ctx: VariableDeclarationContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.procedureAndFunctionDeclarationPart`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProcedureAndFunctionDeclarationPart?: (ctx: ProcedureAndFunctionDeclarationPartContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.procedureOrFunctionDeclaration`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProcedureOrFunctionDeclaration?: (ctx: ProcedureOrFunctionDeclarationContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.procedureDeclaration`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProcedureDeclaration?: (ctx: ProcedureDeclarationContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.formalParameterList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFormalParameterList?: (ctx: FormalParameterListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.formalParameterSection`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFormalParameterSection?: (ctx: FormalParameterSectionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.identifierList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitIdentifierList?: (ctx: IdentifierListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.paramIdentifier`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitParamIdentifier?: (ctx: ParamIdentifierContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.constList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConstList?: (ctx: ConstListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.functionDeclaration`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFunctionDeclaration?: (ctx: FunctionDeclarationContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.assignationFunctionDeclaration`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitAssignationFunctionDeclaration?: (ctx: AssignationFunctionDeclarationContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.resultType`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitResultType?: (ctx: ResultTypeContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.statement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStatement?: (ctx: StatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.breakStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBreakStatement?: (ctx: BreakStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.returnStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitReturnStatement?: (ctx: ReturnStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.continueStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitContinueStatement?: (ctx: ContinueStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unlabelledStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnlabelledStatement?: (ctx: UnlabelledStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.simpleStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSimpleStatement?: (ctx: SimpleStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.assignmentStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitAssignmentStatement?: (ctx: AssignmentStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.variable`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitVariable?: (ctx: VariableContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.accessor`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitAccessor?: (ctx: AccessorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.index`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitIndex?: (ctx: IndexContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.expression`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitExpression?: (ctx: ExpressionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.booleanMultiplicativeExpression`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBooleanMultiplicativeExpression?: (ctx: BooleanMultiplicativeExpressionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.booleanRelationalExpression`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBooleanRelationalExpression?: (ctx: BooleanRelationalExpressionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.relationaloperator`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRelationaloperator?: (ctx: RelationaloperatorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.simpleExpression`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSimpleExpression?: (ctx: SimpleExpressionContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.additiveoperator`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitAdditiveoperator?: (ctx: AdditiveoperatorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.term`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitTerm?: (ctx: TermContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.baseTerm`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitBaseTerm?: (ctx: BaseTermContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.multiplicativeoperator`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitMultiplicativeoperator?: (ctx: MultiplicativeoperatorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.exponentiationOperator`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitExponentiationOperator?: (ctx: ExponentiationOperatorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.signedFactor`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSignedFactor?: (ctx: SignedFactorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.factor`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFactor?: (ctx: FactorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.unsignedConstant`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitUnsignedConstant?: (ctx: UnsignedConstantContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.functionDesignator`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFunctionDesignator?: (ctx: FunctionDesignatorContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.parameterList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitParameterList?: (ctx: ParameterListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.set_`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitSet_?: (ctx: Set_Context) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.elementList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitElementList?: (ctx: ElementListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.element`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitElement?: (ctx: ElementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.procedureStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitProcedureStatement?: (ctx: ProcedureStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.actualParameter`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitActualParameter?: (ctx: ActualParameterContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.parameterwidth`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitParameterwidth?: (ctx: ParameterwidthContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.gotoStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitGotoStatement?: (ctx: GotoStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.emptyStatement_`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitEmptyStatement_?: (ctx: EmptyStatement_Context) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.empty_`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitEmpty_?: (ctx: Empty_Context) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.structuredStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStructuredStatement?: (ctx: StructuredStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.compoundStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitCompoundStatement?: (ctx: CompoundStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.statements`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStatements?: (ctx: StatementsContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.conditionalStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitConditionalStatement?: (ctx: ConditionalStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.ifStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitIfStatement?: (ctx: IfStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.elifStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitElifStatement?: (ctx: ElifStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.elseStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitElseStatement?: (ctx: ElseStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.caseStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitCaseStatement?: (ctx: CaseStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.caseListElement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitCaseListElement?: (ctx: CaseListElementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.caseOtherWise`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitCaseOtherWise?: (ctx: CaseOtherWiseContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.repetetiveStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRepetetiveStatement?: (ctx: RepetetiveStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.whileStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitWhileStatement?: (ctx: WhileStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.repeatStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRepeatStatement?: (ctx: RepeatStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.forStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitForStatement?: (ctx: ForStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.forList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitForList?: (ctx: ForListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.initialValue`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitInitialValue?: (ctx: InitialValueContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.finalValue`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitFinalValue?: (ctx: FinalValueContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.stepValue`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitStepValue?: (ctx: StepValueContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.withStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitWithStatement?: (ctx: WithStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.recordVariableList`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitRecordVariableList?: (ctx: RecordVariableListContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.writeStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitWriteStatement?: (ctx: WriteStatementContext) => Result;
    /**
     * Visit a parse tree produced by `StepCodeParser.readStatement`.
     * @param ctx the parse tree
     * @return the visitor result
     */
    visitReadStatement?: (ctx: ReadStatementContext) => Result;
}

declare class StepValueContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StringContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    STRING_LITERAL(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StringtypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    STRING(): TerminalNode;
    LBRACK(): TerminalNode;
    RBRACK(): TerminalNode;
    identifier(): IdentifierContext;
    unsignedNumber(): UnsignedNumberContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StructuredStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    conditionalStatement(): ConditionalStatementContext;
    repetetiveStatement(): RepetetiveStatementContext;
    withStatement(): WithStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class StructuredTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    PACKED(): TerminalNode;
    unpackedStructuredType(): UnpackedStructuredTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SubprogramContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    procedureOrFunctionDeclaration(): ProcedureOrFunctionDeclarationContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class SubrangeTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    constant_list(): ConstantContext[];
    constant(i: number): ConstantContext;
    DOTDOT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TagContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    COLON(): TerminalNode;
    typeIdentifier(): TypeIdentifierContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TermContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    baseTerm(): BaseTermContext;
    term_list(): TermContext[];
    term(i: number): TermContext;
    multiplicativeoperator(): MultiplicativeoperatorContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class Type_Context extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    simpleType(): SimpleTypeContext;
    structuredType(): StructuredTypeContext;
    pointerType(): PointerTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TypeDefinitionContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    EQUAL(): TerminalNode;
    type_(): Type_Context;
    functionType(): FunctionTypeContext;
    procedureType(): ProcedureTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TypeDefinitionPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    TYPE(): TerminalNode;
    typeDefinition_list(): TypeDefinitionContext[];
    typeDefinition(i: number): TypeDefinitionContext;
    SEMI_list(): TerminalNode[];
    SEMI(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TypeIdentifierContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    CHAR(): TerminalNode;
    BOOLEAN(): TerminalNode;
    INTEGER(): TerminalNode;
    REAL(): TerminalNode;
    STRING(): TerminalNode;
    VOID(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class TypeListContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    indexType_list(): IndexTypeContext[];
    indexType(i: number): IndexTypeContext;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnlabelledStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    simpleStatement(): SimpleStatementContext;
    structuredStatement(): StructuredStatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnpackedStructuredTypeContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    arrayType(): ArrayTypeContext;
    recordType(): RecordTypeContext;
    setType(): SetTypeContext;
    fileType(): FileTypeContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnsignedConstantContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    unsignedNumber(): UnsignedNumberContext;
    constantChr(): ConstantChrContext;
    string_(): StringContext;
    NIL(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnsignedIntegerContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    NUM_INT(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnsignedNumberContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    unsignedInteger(): UnsignedIntegerContext;
    unsignedReal(): UnsignedRealContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UnsignedRealContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    NUM_REAL(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class UsesUnitsPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    USES(): TerminalNode;
    identifierList(): IdentifierListContext;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export declare function validate(code: string): StepCodeError[];

declare class VariableContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifier(): IdentifierContext;
    accessor_list(): AccessorContext[];
    accessor(i: number): AccessorContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class VariableDeclarationContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    identifierList(): IdentifierListContext;
    AS(): TerminalNode;
    type_(): Type_Context;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class VariableDeclarationPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    DEFINE(): TerminalNode;
    variableDeclaration(): VariableDeclarationContext;
    SEMI(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class VariantContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    constList(): ConstListContext;
    COLON(): TerminalNode;
    LPAREN(): TerminalNode;
    fieldList(): FieldListContext;
    RPAREN(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class VariantPartContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    CASE(): TerminalNode;
    tag(): TagContext;
    OF(): TerminalNode;
    variant_list(): VariantContext[];
    variant(i: number): VariantContext;
    SEMI_list(): TerminalNode[];
    SEMI(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class WhileStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    WHILE(): TerminalNode;
    expression(): ExpressionContext;
    compoundStatement(): CompoundStatementContext;
    ENDWHILE(): TerminalNode;
    DO(): TerminalNode;
    HACER(): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class WithStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    WITH(): TerminalNode;
    recordVariableList(): RecordVariableListContext;
    DO(): TerminalNode;
    statement(): StatementContext;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

declare class WriteStatementContext extends ParserRuleContext {
    constructor(parser?: StepCodeParser, parent?: ParserRuleContext, invokingState?: number);
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    SEMI(): TerminalNode;
    WRITE(): TerminalNode;
    WRITELN(): TerminalNode;
    COMMA_list(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    get ruleIndex(): number;
    enterRule(listener: StepCodeListener): void;
    exitRule(listener: StepCodeListener): void;
    accept<Result>(visitor: StepCodeVisitor<Result>): Result;
}

export { }
